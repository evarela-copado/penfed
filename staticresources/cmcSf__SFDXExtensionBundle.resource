{
    "recordTypeMap": {},
    "RecordSetBundles": [
        {
            "Records": [
                {
                    "attributes": {
                        "type": "copado__Function__c",
                        "url": "/services/data/v52.0/sobjects/copado__Function__c/a0k09000000FKgfAAG"
                    },
                    "copado__API_Name__c": "Devhub_Package_Info",
                    "copado__Description__c": "Extracts package and package versions info from a DevHub",
                    "copado__Image_Name__c": "copado-multicloud-dx:v3",
                    "copado__Options__c": "[ ]",
                    "copado__Parameters__c": "[ {\n  \"required\" : true,\n  \"name\" : \"packageNameOrId\",\n  \"defaultValue\" : \"{$Context.JobExecution__r.DataJson.packageNameOrId}\"\n}, {\n  \"required\" : true,\n  \"name\" : \"session\",\n  \"defaultValue\" : \"{$Source.Credential.SessionId}\"\n}, {\n  \"required\" : true,\n  \"name\" : \"baseUrl\",\n  \"defaultValue\" : \"{$Source.Credential.Endpoint}\"\n} ]",
                    "copado__Script__c": "#!/usr/bin/env node\nconst { execSync } = require('child_process'),\n    { session, baseUrl, packageNameOrId } = process.env,\n    url = baseUrl.substring(0, baseUrl.indexOf('/', baseUrl.indexOf('/') + 2)),\n    checkLog = 'Please check the logs for details';\n\n// EXECUTION\n\nexecute();\n\nfunction execute() {\n    try {\n        setInstanceURL();\n        createSFDXProject();\n\n        const pkg = getPackageDetails();\n\n        if (pkg) {\n            const versions = getPackageVersions(pkg.Id),\n                resultObj = JSON.stringify({ pkg, versions });\n\n            const result = `\n\tcopado -p 'Updating Results' -r ${JSON.stringify(resultObj)}\n`;\n            //escaping special characters here, so it can be used in payload\n            execSync(escapeSpecialCharacters(result));\n        } else {\n            throw `Couldn't find details of package ${packageNameOrId} in devHub.`;\n        }\n    } catch (err) {\n        //Error status = 3, is when we have Custom Error Message, where error is already populated on result and hence we do not need to call it again.\n        if (err?.status === 3) {\n            process.exit(1);\n        }\n        execSync(showError(err.toString()));\n    }\n}\n\n// SCRIPT FUNCTIONS\n\nfunction showError(error) {\n    const refinedErrorMsg = maskSensitiveInformation(error);\n    return `copado -p 'Error' -e ${escapeSpecialCharacters(JSON.stringify(refinedErrorMsg)).replace(/\\\\n/g, '\\n').replace(/\\\\t/g, '\\t')} && exit 3`;\n}\n\nfunction setInstanceURL() {\n    execSync(`\n    copado -p 'Setting instance url'\n    sfdx force:config:set instanceUrl=${url} --global || (${showError(`Error setting instance URL, ${checkLog}`)})\n\t`);\n}\n\nfunction createSFDXProject() {\n    execSync(`\n    sfdx force:project:create -n temp || (${showError(`Error creating SFDX project, ${checkLog}`)})\n  `);\n}\n\nfunction getPackageList() {\n    return JSON.parse(\n        execSync(`\n      copado -p 'Getting Package Info'\n      cd temp\n      sfdx force:package:list -v ${session} --json\n\t`).toString()\n    );\n}\n\nfunction getPackageDetails() {\n    const packages = getPackageList();\n    if (packages.status) {\n        throw `${packages.name}: ${packages.message}`;\n    } else {\n        return packages.result.find((element) => element.Name == packageNameOrId || element.Id == packageNameOrId);\n    }\n}\n\nfunction getPackageVersions(packageId) {\n    const versions = JSON.parse(\n        execSync(`\n    cd temp\n    sfdx force:package:version:list -v ${session} -p ${packageId} --json\n  `).toString()\n    );\n\n    if (versions.status) {\n        throw `${versions.name}: ${versions.message}`;\n    } else {\n        return versions.result;\n    }\n}\n\nfunction escapeSpecialCharacters(text) {\n    let result = text.replace(/`/g, '\\\\`').replace(/\\$/g, '\\\\$');\n\n    return result;\n}\n\nfunction maskSensitiveInformation(data) {\n    const sensitiveInfo = ['--targetdevhubusername', '-u', '-v'],\n        maskingSequence = '*****';\n\n    const arrayOfData = data.split(' ');\n    sensitiveInfo.forEach((subString) => {\n        const keyIndex = arrayOfData.indexOf(subString);\n        if (keyIndex > -1) {\n            arrayOfData[keyIndex + 1] = maskingSequence;\n            data = arrayOfData.join(' ');\n        }\n    });\n    return data;\n}",
                    "copado__Type__c": "Standard",
                    "copado__Version__c": "1.0",
                    "copado__Worker_Size__c": "S",
                    "CreatedDate": "2021-09-16T15:20:01.000+0000",
                    "Id": "a0k09000000FKgfAAG",
                    "IsDeleted": false,
                    "LastModifiedDate": "2021-09-28T13:50:51.000+0000",
                    "LastReferencedDate": "2021-09-29T14:36:54.000+0000",
                    "LastViewedDate": "2021-09-29T14:36:54.000+0000",
                    "Name": "Devhub Package Info",
                    "SystemModstamp": "2021-09-28T13:50:51.000+0000"
                },
                {
                    "attributes": {
                      "type": "copado__Function__c",
                      "url": "/services/data/v57.0/sobjects/copado__Function__c/a0l7Q000000iAiJQAU"
                    },
                    "copado__API_Name__c": "sfdx_install_package",
                    "copado__Callback_Type__c": "Flow",
                    "copado__FlowHandler__c": "cmcSf.Installed_Package_Callback",
                    "copado__Image_Name__c": "copado-multicloud-dx:v3",
                    "copado__Options__c": "[ ]",
                    "copado__Parameters__c": "[ {\n  \"required\" : true,\n  \"name\" : \"packages\",\n  \"defaultValue\" : \"{$Job.PrevStep.Result__r.Result_Data__c}\"\n}, {\n  \"required\" : true,\n  \"name\" : \"destinationBaseUrl\",\n  \"defaultValue\" : \"{$Destination.Credential.Endpoint}\"\n}, {\n  \"required\" : true,\n  \"name\" : \"destinationSession\",\n  \"defaultValue\" : \"{$Destination.Credential.SessionId}\"\n}, {\n  \"required\" : false,\n  \"name\" : \"wait\",\n  \"defaultValue\" : \"200\"\n}, {\n  \"name\" : \"apiVersion\",\n  \"defaultValue\" : \"{$Context.JobExecution__r.DataJson.apiVersion}\"\n}, {\n  \"name\" : \"devhubSession\",\n  \"defaultValue\" : \"{$Source.Credential.SessionId}\"\n}, {\n  \"name\" : \"devhubBaseUrl\",\n  \"defaultValue\" : \"{$Source.Credential.Endpoint}\"\n}, {\n  \"name\" : \"installationSecurityType\",\n  \"defaultValue\" : \"{$Context.JobExecution__r.DataJson.installSecurityType}\"\n} ]",
                    "copado__Script__c": "#!/usr/bin/env node\n\nconst { execSync } = require('child_process'),\n    { packages, destinationBaseUrl, destinationSession, wait, apiVersion, devhubSession, devhubBaseUrl, installationSecurityType } = process.env,\n    destinationUrl = getUrl(destinationBaseUrl),\n    devhubUrl = getUrl(devhubBaseUrl);\n\n// EXECUTION\n\nexecute();\n\nfunction execute() {\n    try {\n        const pkgList = JSON.parse(packages),\n            response = getVersionsWithStatus(pkgList),\n            mainPackageId = pkgList.length && pkgList[pkgList.length - 1]?.id;\n\n        const filteredPackages = filterPackagesToInstall(response, pkgList);\n        if (filteredPackages?.length) {\n            setInstanceURL(destinationUrl, 'destination org');\n            installPackages(filteredPackages, mainPackageId);\n        }\n\n        execSync(`copado -p 'Updating Results' -r ${JSON.stringify(JSON.stringify(response))}`);\n    } catch (error) {\n        //Error status = 3, is when we have Custom Error Message, where error is already populated on result and hence we do not need to call it again.\n        if (error?.status === 3) {\n            process.exit(1);\n        }\n        execSync(showErrorCmd(error.toString()));\n    }\n}\n\n// SCRIPT FUNCTIONS\n\nfunction setInstanceURL(url, destination) {\n    execSync(`\n        copado -p 'Setting instance url(${destination})'\n        sfdx force:config:set instanceUrl=${url} --global || (${showErrorCmd(`Error setting instance URL`)})\n    `);\n}\n\nfunction installPackages(pkgList, mainPackageId) {\n    pkgList.forEach(pkg => {\n        if (pkg.id) {\n            const isMainPackage = mainPackageId === pkg.id;\n            executePackageInstallCmd(pkg, isMainPackage);\n        } else {\n            throw 'Could not find Subscriber Package Version Id';\n        }\n    });\n}\n\nfunction executePackageInstallCmd(pkg, isMainPackage) {\n    let params = `-u ${destinationSession} -p ${pkg.id} -w ${wait}`;\n    params += pkg.key ? ` -k '${pkg.key}'` : '';\n    params += apiVersion ? ` --apiversion ${apiVersion}` : '';\n    params += isMainPackage && installationSecurityType ? ` --securitytype ${installationSecurityType}` : '';\n\n    const installCmd = `sfdx force:package:install ${params} --json || true`;\n    logger(`Package Install Command ==> ${installCmd}`);\n\n    const response = JSON.parse(\n        execSync(`\n        copado -p 'Installing package ${pkg.id}'\n        ${installCmd}\n    `).toString()\n    );\n\n    logger(`Package Install Response ==> ${JSON.stringify(response)}`);\n    if (response?.status) {\n        throw `Error for packageID ${pkg.id} : ${response.name}: ${response.message}`;\n    }\n    execSync(`copado -p 'Package \"${pkg.id}\" successfully installed'`);\n}\n\nfunction showErrorCmd(error) {\n    let modifiedError = error + ' ,Please check the logs for details';\n    const refinedErrorMsg = maskSensitiveInformation(modifiedError);\n    return `copado -p 'Error' -e ${escapeSpecialCharacters(JSON.stringify(refinedErrorMsg)).replace(/\\\\n/g, '\\n')} && exit 3`;\n}\n\nfunction logger(text) {\n    console.log(text);\n}\n\nfunction checkVersionFromDevhub(subscriberId, installationKey) {\n    setInstanceURL(devhubUrl, 'devhub');\n\n    const query = `SELECT MajorVersion, MinorVersion, PatchVersion, BuildNumber, SubscriberPackageId FROM SubscriberPackageVersion WHERE Id='${subscriberId}' ${\n        installationKey ? `AND InstallationKey='${installationKey}'` : ''\n    }`;\n    let result = execSync(`\n            copado -p 'Querying SubscriberPackageVersion Tooling API'\n\t\t\tsfdx force:data:soql:query -t -q \"${query}\" -u ${devhubSession} --json || true\n\t\t`).toString();\n    logger(`SubscriberPackageVersion Tooling API response => ${result}`);\n\n    result = JSON.parse(result);\n    if (result?.status) {\n        throw `${result?.name} - ${result?.message}`;\n    }\n    return result;\n}\n\nfunction getInstalledPackageVersion(SubscriberPackageId) {\n    setInstanceURL(destinationUrl, 'destination org');\n\n    const query = `SELECT Id, SubscriberPackageId, SubscriberPackage.NamespacePrefix, SubscriberPackage.Name, SubscriberPackageVersion.Id, SubscriberPackageVersion.Name, SubscriberPackageVersion.MajorVersion, SubscriberPackageVersion.MinorVersion, SubscriberPackageVersion.PatchVersion, SubscriberPackageVersion.BuildNumber FROM InstalledSubscriberPackage where SubscriberPackageId = '${SubscriberPackageId}'`;\n    let result = execSync(`\n            copado -p 'Querying InstalledSubscriberPackage Tooling API'\n\t\t\tsfdx force:data:soql:query -t -q \"${query}\" -u ${destinationSession} --json || true\n\t\t`).toString();\n    logger(`InstalledSubscriberPackage Tooling API response => ${result}`);\n\n    result = JSON.parse(result);\n    if (result?.status) {\n        throw `${result?.name} - ${result?.message}`;\n    }\n    return result;\n}\n\nfunction compareVersion(installed, installing) {\n    const value = installed.localeCompare(installing, undefined, { numeric: true, sensitivity: 'base' });\n    return value < 0;\n}\n\nfunction checkVersionCompatibility(pkg) {\n    let installPkg = true,\n        version = !pkg.subscriberPackageId && checkVersionFromDevhub(pkg.id, pkg.key);\n\n    if (version?.result?.records.length || pkg.subscriberPackageId) {\n        const installedVersion = getInstalledPackageVersion(version?.result?.records[0].SubscriberPackageId || pkg.subscriberPackageId);\n\n        if (installedVersion?.result?.totalSize) {\n            const installed = installedVersion.result.records[0].SubscriberPackageVersion,\n                installing = version?.result?.records[0];\n\n            installPkg = compareVersion(generateVersionName(installed), installing ? generateVersionName(installing) : pkg.versionNumber);\n        }\n    }\n    return installPkg ? 'success' : 'skipped';\n}\n\nfunction generateVersionName(version) {\n    return `${version.MajorVersion}.${version.MinorVersion}.${version.PatchVersion}.${version.BuildNumber}`;\n}\n\nfunction getVersionsWithStatus(packages) {\n    let subscriberIds = [];\n    packages.forEach((pkg) => {\n        subscriberIds.push({ versionId: pkg.id, status: checkVersionCompatibility(pkg) });\n    });\n    return subscriberIds;\n}\n\nfunction filterPackagesToInstall(response, listOfPackages) {\n    return response.reduce((filtered, option) => {\n        if (option.status === 'success') {\n            filtered.push({ id: option.versionId, key: listOfPackages.find((pkg) => pkg.id === option.versionId).key });\n        }\n        return filtered;\n    }, []);\n}\n\nfunction getUrl(baseUrl) {\n    return baseUrl.substring(0, baseUrl.indexOf('/', baseUrl.indexOf('/') + 2));\n}\n\nfunction escapeSpecialCharacters(text) {\n    let result = text.replace(/`/g, '\\\\`').replace(/\\$/g, '\\\\$');\n\n    return result;\n}\n\nfunction maskSensitiveInformation(data) {\n    const sensitiveInfo = ['--targetdevhubusername', '-u', '-v'],\n        maskingSequence = '*****';\n\n    const arrayOfData = data.split(' ');\n    sensitiveInfo.forEach((subString) => {\n        const keyIndex = arrayOfData.indexOf(subString);\n        if (keyIndex > -1) {\n            arrayOfData[keyIndex + 1] = maskingSequence;\n            data = arrayOfData.join(' ');\n        }\n    });\n    return data;\n}",
                    "copado__Timeout__c": 200,
                    "copado__Type__c": "Standard",
                    "copado__Version__c": "1.0",
                    "Id": "a0l7Q000000iAiJQAU",
                    "LastReferencedDate": "2023-02-09T12:43:39.000+0000",
                    "LastViewedDate": "2023-02-09T12:43:39.000+0000",
                    "Name": "Sfdx Install Package"
                  },
                {
                    "attributes": {
                        "type": "copado__Function__c",
                        "url": "/services/data/v56.0/sobjects/copado__Function__c/a0l7Q000000MDYvQAO"
                    },
                    "copado__API_Name__c": "sfdx_deploy",
                    "copado__Callback_Type__c": "Flow",
                    "copado__Description__c": "Deploys promotion branch",
                    "copado__FlowHandler__c": "cmcSf.Update_Validation_Id_on_Promotion",
                    "copado__Image_Name__c": "copado-multicloud-dx:v3",
                    "copado__Options__c": "[ ]",
                    "copado__Parameters__c": "[ {\n  \"required\" : true,\n  \"name\" : \"file_changes_id\",\n  \"defaultValue\" : \"{$Context.JobExecution__r.DataJson.fileWithSelectedChanges}\"\n}, {\n  \"required\" : true,\n  \"name\" : \"promotion\",\n  \"defaultValue\" : \"{$Context.JobExecution__r.DataJson.promotionBranchName}\"\n}, {\n  \"required\" : true,\n  \"name\" : \"target_branch\",\n  \"defaultValue\" : \"{$Context.JobExecution__r.DataJson.destinationBranchName}\"\n}, {\n  \"required\" : true,\n  \"name\" : \"destinationInstanceUrl\",\n  \"defaultValue\" : \"{$Destination.Credential.Endpoint}\"\n}, {\n  \"required\" : true,\n  \"name\" : \"destinationSessionid\",\n  \"defaultValue\" : \"{$Destination.Credential.SessionId}\"\n}, {\n  \"required\" : true,\n  \"name\" : \"git_json\",\n  \"defaultValue\" : \"{$Context.Repository.Credential}\"\n}, {\n  \"required\" : true,\n  \"name\" : \"destination_env\",\n  \"defaultValue\" : \"{$Destination.apex.EnvironmentVariables}\"\n}, {\n  \"name\" : \"find_and_replace_rules\",\n  \"defaultValue\" : \"{$Context.apex.GlobalFindAndReplaceDestinationId}\"\n}, {\n  \"required\" : true,\n  \"name\" : \"conflict_resolution_attachments\",\n  \"defaultValue\" : \"{$Context.apex.GetConflictResolutionAttachments}\"\n}, {\n  \"required\" : true,\n  \"name\" : \"deploy_id\",\n  \"defaultValue\" : \"{$Job.ExecutionParent.Id}\"\n}, {\n  \"required\" : true,\n  \"name\" : \"isValidation\",\n  \"defaultValue\" : \"{$Context.JobExecution__r.DataJson.deploymentDryRun}\"\n}, {\n  \"name\" : \"git_name\",\n  \"defaultValue\" : \"{$User.Name}\"\n}, {\n  \"name\" : \"git_email\",\n  \"defaultValue\" : \"{$User.Email}\"\n}, {\n  \"name\" : \"repository_id\",\n  \"defaultValue\" : \"{$Pipeline.Git_Repository__r.Id}\"\n}, {\n  \"name\" : \"testLevel\",\n  \"defaultValue\" : \"{$Job.ExecutionParent.Promotion__r.cmcSf__Apex_Test_Level__c}\"\n}, {\n  \"name\" : \"testOnlyClasses\",\n  \"defaultValue\" : \"{$Context.apex.cmcSf.GetTestOnlyClasses}\"\n}, {\n  \"name\" : \"debugMode\",\n  \"defaultValue\" : \"{$Job.ExecutionParent.Promotion__r.cmcSf__Debug_Mode__c}\"\n}, {\n  \"name\" : \"git_depth\",\n  \"defaultValue\" : \"100\"\n}, {\n  \"name\" : \"validationId\",\n  \"defaultValue\" : \"{$Job.ExecutionParent.Promotion__r.cmcSf__Validate_Deploy_Request_Id__c}\"\n}, {\n  \"name\" : \"testClasses\",\n  \"defaultValue\" : \"{$Context.apex.cmcSf.GetTestClasses}\"\n}, {\n  \"name\" : \"maxBuffer\",\n  \"defaultValue\" : \"5242880\"\n}, {\n  \"name\" : \"waitTime\",\n  \"defaultValue\" : \"220\"\n}, {\n  \"name\" : \"sourceInstanceUrl\",\n  \"defaultValue\" : \"{$Source.Credential.Endpoint}\"\n}, {\n  \"name\" : \"sourceSessionid\",\n  \"defaultValue\" : \"{$Source.Credential.SessionId}\"\n}, {\n  \"name\" : \"mergeProfile\",\n  \"defaultValue\" : \"false\"\n}, {\n  \"name\" : \"overriddenApiVersion\",\n  \"defaultValue\" : \"\"\n} ]",
                    "copado__Script__c": "#!/usr/bin/env node\n/**\n * Performs deploy of selected user story metadata changes.\n * Returns (If ACTION success) destination branch with merged changes of the user story metadata\n * (If ACTION failed) Returns details with error status on the job execution\n * @param file_changes_id\n * @param promotion\n * @param target_branch\n * @param destinationInstanceUrl\n * @param destinationSessionid\n * @param git_json\n * @param destination_env\n * @param find_and_replace_rules\n * @param conflict_resolution_attachments\n * @param deploy_id\n * @param isValidation\n * @param git_name\n * @param git_email\n * @param repository_id\n * @param testLevel\n * @param testClasses\n * @param testOnlyClasses\n * @param maxBuffer\n * @param sourceSessionid\n * @param sourceInstanceUrl\n * @param waitTime\n * @param mergeProfile\n*/\n\nconst { spawnSync } = require('child_process'),\n    { writeFileSync, existsSync, readFileSync, rmSync, statSync } = require('fs'),\n    { env, chdir, exit } = require('process'),\n    ENCODED_CHANGES_FILE = 'encoded_changes.json',\n    { destinationSessionid, promotion, target_branch, isValidation, maxBuffer, destinationInstanceUrl, mergeProfile, overriddenApiVersion, API_VERSION } = env,\n    TARGET_DIRECTORY = \"/app/repository\",\n    ACTIONS = {\n        ADD: 'add',\n        RETRIEVE_ONLY: 'retrieveonly',\n        FULL: 'full',\n        DELETE: 'delete'\n    },\n    TYPES = {\n        PERMISSION_SET: 'permissionset',\n        PROFILE: 'profile'\n    },\n    STDIO = {\n        INHERIT: 'inherit',\n        PIPE: 'pipe',\n        IGNORE: 'ignore'\n    },\n    MAXBUFFER = parseInt(maxBuffer),\n    METADATA_FOR_MERGE_IN_PROFILE =  [\n        'apexclass',\n        'customapplication',\n        'customobject',\n        'customfield',\n        'layout',\n        'apexpage',\n        'customtab',\n        'recordtype',\n        'systempermissions',\n    ],\n    SOURCE_API_VERSION = getApiVersion();\n\nlet commitedMetadata = {};\n\n// EXECUTION\n\nexecute();\n\nfunction execute() {\n    const { debugMode, target_branch, validationId } = env;\n    let debugBranch;\n    try {\n        prepareMetadataChangesList();\n        getPromotionAndConfigureGit();\n        gitMergePromotionToTarget();\n        checkSFDXProjectJson();\n        processFullProfiles();\n        if(debugMode === \"true\") {\n            debugBranch = `copadoDebug/${promotion?.split('/')[1]}`;\n            createDebugPromotionBranch(debugBranch);\n        }\n        processMetadata();\n        replaceEnvironmentVariablesAndReplaceYAML();\n        if(debugMode === \"true\") {\n            pushDebugPromotionBranch(debugBranch);\n        }\n        setSFDXConfig(destinationInstanceUrl);\n        if(isValidation === \"false\" && validationId) {\n            executeQuickDeploy(validationId);\n        }\n        else {\n            handleDeployResult(copadoStartDeployment());\n        }\n        cleanSfdxProjectConfigFiles();\n        if(isValidation === \"false\") {   \n            pushChangesToRemote(target_branch);\n        }\n    } catch (err) {\n        executeCommand(getErrorCmdString(err.toString()));\n        exit(1);\n    }\n}\n\n// SCRIPT FUNCTIONS\n\nfunction prepareMetadataChangesList() {\n    commitedMetadata.all = readFromPath(`/app/${ENCODED_CHANGES_FILE}`);\n    commitedMetadata = {\n        ...commitedMetadata,\n        add: commitedMetadata.all.filter(selectedMetadata => (selectedMetadata.a.toLowerCase() == ACTIONS.RETRIEVE_ONLY || selectedMetadata.a.toLowerCase() == ACTIONS.ADD || (selectedMetadata.a.toLowerCase() == ACTIONS.FULL && selectedMetadata.t.toLowerCase() != TYPES.PROFILE))),\n        delete: commitedMetadata.all.filter(selectedMetadata => selectedMetadata.a.toLowerCase() == ACTIONS.DELETE),\n        profiles: commitedMetadata.all.filter(selectedMetadata => selectedMetadata.a.toLowerCase() == ACTIONS.FULL && selectedMetadata.t.toLowerCase() == TYPES.PROFILE),\n        getMetadataList(type) {\n            return this[type].map(step => step.t + ':' + step.n).toString(',');\n        }\n    }\n    if(commitedMetadata?.profiles?.length) {\n        commitedMetadata.fullProfileList = commitedMetadata?.profiles?.map(profile => profile.n).toString(',');\n    }\n}\n\nfunction getPromotionAndConfigureGit() {\n    const {\n        git_email,\n        git_name\n    } = env;\n\n        executeCommand(`\n            sfdx -v\n            # Get Promotion\n            mkdir -p ${TARGET_DIRECTORY}\n            cd ${TARGET_DIRECTORY}\n            copado --progress \"fetching ${promotion}\"\n            copado-git-get \"${promotion}\" || ${getErrorCmdString('Error fetching promotion branch')}\n\n            # Configure Git\n            git config --local user.email \"${git_email}\" || exit 1\n            git config --local user.name \"${git_name}\" || exit 1\n            git config --global diff.renames false || exit 1\n            git config --global merge.renames false || exit 1\n            git config --global status.renames false || exit 1\n        `, STDIO.INHERIT);\n        chdir(TARGET_DIRECTORY);\n}\n\nfunction checkSFDXProjectJson() {\n    const sfdxProjectJsonPath = `${TARGET_DIRECTORY}/sfdx-project.json`;\n    if(existsSync(sfdxProjectJsonPath)) {\n        let fileContent = JSON.parse(readFileSync(sfdxProjectJsonPath, { encoding:'utf8' }));\n        if(fileContent.sourceApiVersion !== SOURCE_API_VERSION) {\n            const commitMessage = `Updated  sourceApiVersion from ${fileContent.sourceApiVersion} to ${SOURCE_API_VERSION} in sfdx-project.json to align the commit, promote and deploy operations with the latest supported api version of Copado.`;\n            fileContent.sourceApiVersion = SOURCE_API_VERSION;\n            writeFileSync(sfdxProjectJsonPath, JSON.stringify(fileContent, null, 2));\n            commitGit(commitMessage); \n        }\n    } else {\n        throw \"Invalid configuration. sfdx-project.json is invalid or missing at project root. Copado Commit and Deploy operations are required to run from within a valid sfdx project.\";\n    }\n}\n\nfunction enrichChangeList(filePath) {\n    executeCommand(`\n    copado -p \"Processing metadata\"\n    enricher -p ${filePath} --repo ${TARGET_DIRECTORY}/ || ${getErrorCmdString(\"Error finding file paths for the deployed changes\")}`);\n}\n\nfunction processMetadata() {\n\n    executeCommand(`\n    metadata-processor \"/app/${ENCODED_CHANGES_FILE}\" \"${TARGET_DIRECTORY}\" -o TRIM --enrich || ${getErrorCmdString(\"Error processing metadata\")}`, STDIO.INHERIT);\n    if(existsSync(`/app/internal_${ENCODED_CHANGES_FILE}`)) {\n        addParentMetadataToOriginalChangeList(readFromPath(`/app/internal_${ENCODED_CHANGES_FILE}`));\n    }\n}\nfunction addParentMetadataToOriginalChangeList(parentMetadataList) {\n    commitedMetadata.add = commitedMetadata.add.concat(parentMetadataList.filter(change => change.a.toLowerCase() == ACTIONS.ADD));\n}\n\n\nfunction varReplace() {\n    const { destination_env } = env;\n\n\n    const varreplace = `\n    copado -p \"Replacing environment variables, if any\"\n    varreplace '${destination_env}' '${TARGET_DIRECTORY}' || ${getErrorCmdString(\"Error replacing environment variables\")}`;\n\n    executeCommand(varreplace, STDIO.INHERIT);\n}\n\nfunction replaceEnvironmentVariablesAndReplaceYAML() {\n    const {\n        find_and_replace_rules\n    } = env;\n\n    if(commitedMetadata.add?.length > 0 || commitedMetadata.profiles?.length > 0) {\n        varReplace();\n\n        executeCommand(`\n            copado -p \"Applying global find and replace rules, if any\"\n            if [ -z \"${find_and_replace_rules}\" ]\n            then\n                echo \"No yaml file found\"\n            else\n                copado --downloadfiles \"${find_and_replace_rules}\" --downloaddir /tmp/ || ${getErrorCmdString(\"Error downloading Copado.yml file\")}\n\n                # YAML Replace service called, Target Dir:  \"/tmp/Copado\", Path to YML: \"/app/repository/\"\n                yamlreplace \"/tmp/Copado\" \"${TARGET_DIRECTORY}\" -b \"${promotion}\" ||  ${getErrorCmdString(\"Error applying global find and replace rules\")}\n            fi\n        `, STDIO.INHERIT);\n    }  \n}\n \nfunction copadoStartDeployment() {\n\n    const addManifest = commitedMetadata.profiles?.concat(commitedMetadata.add).filter(meta => meta != undefined);\n    let manifestCreation = `\n        copado --progress 'Deploying ${commitedMetadata.getMetadataList(ACTIONS.ADD).substring(0,240)}...'\n        sfdx force:source:manifest:create -m '${addManifest.length ? addManifest.map(step => step.t + \":\" + step.n).toString() : \"\"}'\n    `;\n    commitedMetadata.delete.length && (manifestCreation += `\\nsfdx force:source:manifest:create -m '${commitedMetadata.getMetadataList('delete')}' --manifesttype destroy`);\n\n    executeCommand(manifestCreation, STDIO.INHERIT);\n    return executeSFDXcommand(`(${createSfdxDeploy()}) || true`);\n    \n}\n\nfunction executeSFDXcommand(command) {\n    return JSON.parse(executeCommand(command));\n}\n\n\n// Create SFDX Deploy command w.r.t. to flags\nfunction createSfdxDeploy() {\n    const { waitTime } = env;\n    let sfdxDeployCommand = `sfdx force:source:deploy --json ${ waitTime ? '-w ' + parseInt(waitTime) : ''}`;\n    \n    if(isValidation === 'true') {\n        sfdxDeployCommand += \" --checkonly\";\n    }\n    sfdxDeployCommand += ` --targetusername ${destinationSessionid}`;\n\n    sfdxDeployCommand += getTestRunParam();\n\n    sfdxDeployCommand += \" --manifest package.xml\" + (commitedMetadata.delete.length ? \" --postdestructivechanges destructiveChanges.xml -g\" : \"\");\n    console.log(`Deploy command: ${sfdxDeployCommand}`);\n    return `${sfdxDeployCommand} || true`;\n}\nfunction getTestRunParam() {\n    let testRunParam = '';\n    const { testLevel } = env;\n    if(testLevel) {\n        const testRun = testLevel?.split(' ')?.join('');\n        if (testRun) {\n            testRunParam += ` -l ${testRun}`;\n            if(testRun === \"RunSpecifiedTests\") {\n                testRunParam += `${ \" -r \" + getDeploymentTestClasses()}`\n            }\n        }\n    }\n    return testRunParam;\n}\n\nfunction getDeploymentTestClasses() {\n   const { testOnlyClasses, testClasses } = env;\n   let deploymentTestClasses = new Set();\n    if(testOnlyClasses) {\n        deploymentTestClasses = new Set([...deploymentTestClasses, ...(testOnlyClasses?.split(','))]);\n    }\n    if(testClasses) {\n        deploymentTestClasses = new Set([...deploymentTestClasses, ...(testClasses?.split(','))]);\n    }\n    if(!deploymentTestClasses.size) {\n        throw \"No Test Classes were selected by the User\";\n    }\n    return [...deploymentTestClasses].join(',');\n}\n\nfunction uploadDeploymentResultOnJobStep(deployResult) {\n    const deployResultDir = `/app/${isValidation === \"true\" ? 'Validation':'Deployment'}Result.json`;\n\n    writeFileSync(deployResultDir, JSON.stringify(deployResult, null, 2));\n    executeCommand(`copado --uploadfile ${deployResultDir}`, STDIO.INHERIT);\n}\n\nfunction handleDeployResult(deployResult) {\n\n    uploadDeploymentResultOnJobStep(deployResult);\n\n    let errorResponse = '';\n    const deployResultDetails = deployResult?.result?.details,\n       failedMetadata = deployResultDetails?.componentFailures,\n       warningSuccessMetadata = deployResultDetails?.componentSuccesses,\n       failedTests = deployResultDetails?.runTestResult?.failures,\n       codeCoverageWarnings = deployResultDetails?.runTestResult?.codeCoverageWarnings,\n       filterFailedMedataProblemType = (statusInfo, type) => {\n            let result = [];\n            if(Array.isArray(statusInfo)) {\n                result = statusInfo.filter(status => status.problemType == type);\n            } else if(statusInfo.problemType == type) {\n                result = [statusInfo];\n            }\n            return result;\n       },\n       getFailedMedataErrorMessage = (failedTests) => {\n            let result = '';\n            if(Array.isArray(failedTests)) {\n                let failedTestsError = failedTests.map(fail => {\n                    let mappedValue = \"\";\n                    if(fail.name) {\n                        mappedValue = mappedValue.concat(fail.name);\n                    }\n                    if(fail.methodName) {\n                        mappedValue =  mappedValue.concat(`${fail.methodName}-`);\n                    }\n                    mappedValue = mappedValue.concat(fail.message);\n                    return mappedValue;\n                });\n                if(failedTestsError?.length) {\n                    result = failedTestsError.join(\"\\n\");\n                }\n            }\n            else {\n                if(typeof failedTests.name != 'object') {\n                    result = result.concat(`${failedTests.name}-`);\n                }\n                if(failedTests.methodName) {\n                    result = result.concat(failedTests.methodName);\n                }\n                result = result.concat(failedTests.message);\n            }\n            return result;\n       },\n       getFailedDeploymentMessage = (problem) => {\n            let result = '';\n            if(Array.isArray(problem)) {\n                result = problem.map(fail => fail['componentType'].concat(':', fail['fullName'], ':', fail['problem'])).join(\"\\n\");\n            }\n            else {\n                result = problem['componentType'].concat(':', problem['fullName'], ':', problem['problem']).toString();\n            }\n            return result;\n       };\n       \n   // If any errors or warning, display to progress indicator and fail the job execution\n   if (deployResult?.status) {\n        if(deployResult?.message) {\n            errorResponse = `${deployResult?.message}`;\n        }\n        else if(deployResult?.result?.errorMessage) {\n            errorResponse = `${deployResult?.result?.errorMessage}`;\n        }\n        else if(deployResult?.result.status == 'Canceled') {\n            errorResponse = `The ${ isValidation === 'true' ? 'validation' : 'deployment' } was cancelled on the target org.`;\n        }\n   }\n   if (failedTests) {\n       errorResponse = populateErrorResponse(getFailedMedataErrorMessage(failedTests), errorResponse);\n      }\n   if (codeCoverageWarnings) {\n       errorResponse = populateErrorResponse(getFailedMedataErrorMessage(codeCoverageWarnings), errorResponse);\n   }\n   if (failedMetadata) {\n       const errorMetadata = filterFailedMedataProblemType(failedMetadata, \"Error\");\n       if(errorMetadata.length){\n        errorResponse = populateErrorResponse(getFailedDeploymentMessage(errorMetadata), errorResponse);\n       }\n   }\n   if(warningSuccessMetadata?.length) {\n       const warningMetadata = filterFailedMedataProblemType(warningSuccessMetadata, \"Warning\");\n       if(warningMetadata?.length) {\n           message = `WARNING deploying Metadata: ${getFailedDeploymentMessage(warningMetadata)}`;\n           executeCommand(`copado -p \"${message.substring(0,254)}\"`);\n           console.log(message);\n       }\n   }\n   if(errorResponse) {\n        executeCommand(getErrorCmdString(errorResponse.substring(0,131072)));\n   }\n\n   if(!deployResult.status && isValidation === \"true\") {\n       populateValidationIdOnResultRecord(deployResult.result.id);\n   }\n}\n\nfunction populateErrorResponse(errorMessage, errorResponse) {\n    const delimeter = \"\\n\";\n    errorResponse = (errorResponse && errorResponse?.trim().concat(`${delimeter}`, errorMessage.trim())) || errorResponse.concat(errorMessage.trim());\n    return errorResponse;\n}\n\nfunction cleanSfdxProjectConfigFiles() {\n    const cleanUp = `\n        git reset --hard\n        rm -rf package.xml destructiveChanges.xml\n    `;\n    executeCommand(cleanUp);\n}\n\nfunction gitMergePromotionToTarget() {\n    const { git_depth } = env;\n \n    let readyToMerge = `\n        git reset --hard || exit 1\n        copado --progress \"merging ${promotion} into ${target_branch}\"\n        copado-git-get --depth ${git_depth} \"${target_branch}\" ||  ${getErrorCmdString('Error fetching target branch')}\n        git merge \"${promotion}\"  --no-commit -Xignore-space-change || true\n    `;\n    executeCommand(readyToMerge, STDIO.INHERIT);\n\n    evaluateMergeStatus();\n    commitGit(`Merging ${promotion} into ${target_branch} after auto conflict resolution`);\n}\n\nfunction commitGit(commitMessage) {\n    executeCommand(`           \n        git add . # add all the resolved changes, if any \n        git commit -am \"${commitMessage}\" || true`, STDIO.INHERIT);\n}\n\nfunction evaluateMergeStatus() {\n        gitStatus = executeCommand('git status --porcelain=v1 -uno'),\n        porcelainStatus = gitStatus.split('\\n').map(str => str.split(' ')?.[0]),\n        isConflict = porcelainStatus.length ? ['AA', 'UU', 'DD', 'UA', 'UD', 'DU', 'AU'].some(s => porcelainStatus.includes(s)) : false;\n    let infoMessage;\n\n    if(isConflict)\n        executeCommand(getErrorCmdString(`Changes detected in target branch '${target_branch}' after promotion branch '${promotion}' was created, please recreate promotion branch out of the new target branch state.`));\n    else if(!gitStatus) {\n        infoMessage = 'Already up to date';\n    }\n    else {\n        infoMessage = `Changes detected in target branch '${target_branch}' after promotion branch '${promotion}' was created.`;\n       \n    }\n    infoMessage && executeCommand(`copado -p \"${infoMessage}\"`);\n    console.log(infoMessage);\n}\n\nfunction reconcileFullProfile() {\n    if (commitedMetadata?.profiles?.length) {\n        let reconciledProfileOutput = executeCommand(`\n                copado -p \"Reconciling full profile\"\n                sfdx sfpowerkit:source:profile:reconcile -u \"${destinationSessionid}\" -n \"${commitedMetadata?.fullProfileList}\" --json || true\n        `);\n        if (!reconciledProfileOutput) {\n            throw \"Error reconciling full profile\";\n        }\n        evaluateResponse(reconciledProfileOutput);\n    }\n}\n\nfunction pushChangesToRemote(remoteBranchName) {\n    executeCommand(`git push origin \"${remoteBranchName}\" || ${getErrorCmdString(\"Could not push the changes to \" +remoteBranchName)}`, STDIO.INHERIT);\n}\n\nfunction createDebugPromotionBranch(debugBranch) {\n\n    executeCommand(`\n    exists=$(git show-ref refs/heads/${debugBranch})\n    if [ -n \"$exists\" ]; then\n        copado -p \"Removing local debug branch ${debugBranch}\"\n        git branch -d ${debugBranch}\n    fi\n    git checkout -b ${debugBranch}\n    `, STDIO.INHERIT);\n}\n\nfunction pushDebugPromotionBranch(debugBranch) {\n    executeCommand(`copado -p \"Pushing changes to ${debugBranch}\"`);\n    commitGit(`Copado Debug Branch Commit for Promotion ${debugBranch}`);\n    executeCommand(`git push -f origin ${debugBranch} || copado -p \"Could not push changes to ${debugBranch}\"`, STDIO.INHERIT);\n}\n\nfunction setSFDXConfig(instanceUrl) {\n    const baseUrl = instanceUrl.substring(0, instanceUrl.indexOf('/', instanceUrl.indexOf('/') + 2));\n    executeCommand(`\n    # Set instance URL within sfdx-config.json\n    sfdx config:set instanceUrl=${baseUrl} || ${getErrorCmdString('Error setting instanceUrl : ' + baseUrl)}`);\n}\n\nfunction getErrorCmdString(error) {\n    const suffix = 'Please check the logs for details.'\n    return `{ copado -p \"Error\" -e \"${error.trim()}; ${suffix}\"; exit 1; }`\n}\n\nfunction populateValidationIdOnResultRecord(validationId) {\n   executeCommand(`copado -p \"Saving validation id\" -r '${JSON.stringify({validationId})}' && exit 0`);\n}\n\nfunction executeQuickDeploy(validationId) {\n    const quickDeployResult = executeSFDXcommand(`sfdx force:source:deploy --json -q ${validationId} -u ${destinationSessionid}|| true`);\n    if(quickDeployResult.status) {\n        executeCommand(`copado -p \"${quickDeployResult.message}\"`);\n        handleDeployResult(copadoStartDeployment());\n    }\n    else {\n        uploadDeploymentResultOnJobStep(quickDeployResult);\n        executeCommand(`copado -p \"Quick Deploy done successfully\"`);\n    }\n}\n\nfunction readFromPath(filePath) {\n    return JSON.parse(readFileSync(filePath, 'utf-8'));\n}\n\nfunction getFilePaths(changeFilePath, actions) {\n    let changeList = readFromPath(changeFilePath);\n    let filePaths = new Set();\n    if(actions?.length) {\n        changeList = changeList.filter(change => actions.includes(change.a.toLowerCase()));\n    };\n    changeList.forEach(change => {\n        if(change.j) {\n            const filesToBeAdded = (JSON.parse(change.j).filePath).filter(file => existsSync(file) && statSync(file).isFile());\n            filePaths = new Set([...filePaths, ...filesToBeAdded]);\n          }\n    });\n    return [...filePaths];\n}\n\nfunction executeCommand(cmd, ioconfig) {\n    const options = {\n         shell: true,\n         maxBuffer:  MAXBUFFER\n    };\n    if(ioconfig) {\n        options.stdio = ioconfig;\n    }\n    const response = spawnSync(cmd, options);\n    if(response?.status != 0) {\n        if(response?.status == 1) {\n            exit(1);\n        }\n        if(response?.stderr) {\n            throw response?.stderr;\n        }\n    }\n    return response?.stdout?.toString();\n}\n\nfunction processFullProfiles() {\n    if (commitedMetadata?.profiles?.length) {\n        const { sourceInstanceUrl } = env;\n        setSFDXConfig(destinationInstanceUrl);\n        reconcileFullProfile();\n        setSFDXConfig(sourceInstanceUrl);\n        mergeFullProfile();\n        rmSync(\"sfpowerkit-cache.db\", {\n            force: true,\n        });\n        commitGit(`Cleaned full profile in promotion ${promotion}`);\n    }\n}\n\nfunction mergeFullProfile() {\n        if(mergeProfile === 'true') {\n            const metadataList = findMergeableMetadataInScope();\n            if(metadataList?.length) {\n                const { sourceSessionid } = env;\n                executeCommand(`copado -p \"Merging selected metadata permissions to the profile\"`, STDIO.IGNORE);\n                const mergeProfile = `sfdx sfpowerkit:source:profile:merge -n \"${commitedMetadata.fullProfileList}\" -u ${sourceSessionid} -m '${metadataList.join(',')}' --json || true`;\n                const response = executeCommand(mergeProfile);\n                if (!response) {\n                    throw \"Error merging permissions to full profile\";\n                }\n                evaluateResponse(response);\n            }\n    }\n}\n\nfunction findMergeableMetadataInScope() {\n    const metadataList = [];\n    commitedMetadata?.add?.forEach( change => {\n        if(METADATA_FOR_MERGE_IN_PROFILE.includes(change?.t?.toLowerCase())) {\n            metadataList.push(`${change?.t}:${change?.n}`);\n        }\n    }); \n    return metadataList;\n}\nfunction evaluateResponse(response) {\n    response = JSON.parse(response);\n    if (response?.status && response?.message) {\n        executeCommand(getErrorCmdString(`${response.commandName + \": \" + response.message}`));\n    }\n}\n\nfunction getApiVersion() {\n    const finalApiVersion = overriddenApiVersion || API_VERSION;\n    const regExpApiVersion = /\\d\\d\\.0/;\n    if(!(regExpApiVersion.test(finalApiVersion))) {\n        executeCommand(getErrorCmdString('Invalid API Version'));\n    }\n    return finalApiVersion;\n}",
                    "copado__Timeout__c": 120,
                    "copado__Type__c": "Standard",
                    "copado__Worker_Size__c": "M",
                    "Id": "a0l7Q000000MDYvQAO",
                    "LastReferencedDate": "2023-01-16T13:46:38.000+0000",
                    "LastViewedDate": "2023-01-16T13:46:38.000+0000",
                    "Name": "Deploy"
                },
                {
                    "attributes": {
                      "type": "copado__Function__c",
                      "url": "/services/data/v57.0/sobjects/copado__Function__c/a0l7Q000000MDYwQAO"
                    },
                    "copado__API_Name__c": "sfdx_commit",
                    "copado__Callback_Type__c": "Flow",
                    "copado__Description__c": "Performs git commit on user stories",
                    "copado__FlowHandler__c": "cmcSf.Commit_Function_Callback",
                    "copado__Image_Name__c": "copado-multicloud-dx:v3",
                    "copado__Options__c": "[ ]",
                    "copado__Parameters__c": "[ {\n  \"required\" : true,\n  \"name\" : \"fileChangesId\",\n  \"defaultValue\" : \"{$Context.JobExecution__r.DataJson.fileWithSelectedChanges}\"\n}, {\n  \"required\" : true,\n  \"name\" : \"fileName\",\n  \"defaultValue\" : \"Copado Commit changes\"\n}, {\n  \"required\" : true,\n  \"name\" : \"sourceSessionId\",\n  \"defaultValue\" : \"{$Source.Credential.SessionId}\"\n}, {\n  \"required\" : true,\n  \"name\" : \"sourceEndPoint\",\n  \"defaultValue\" : \"{$Source.Credential.Endpoint}\"\n}, {\n  \"name\" : \"namespace\",\n  \"defaultValue\" : \"\"\n}, {\n  \"required\" : true,\n  \"name\" : \"git_json\",\n  \"defaultValue\" : \"{$Context.Repository.Credential}\"\n}, {\n  \"required\" : true,\n  \"name\" : \"baseBranch\",\n  \"defaultValue\" : \"{$Context.JobExecution__r.DataJson.baseBranch}\"\n}, {\n  \"required\" : true,\n  \"name\" : \"sourceEnv\",\n  \"defaultValue\" : \"{$Source.apex.EnvironmentVariables}\"\n}, {\n  \"required\" : false,\n  \"name\" : \"findAndReplaceFileId\",\n  \"defaultValue\" : \"{$Context.apex.GlobalFindAndReplaceSourceId}\"\n}, {\n  \"required\" : true,\n  \"name\" : \"featureBranch\",\n  \"defaultValue\" : \"{$Context.JobExecution__r.DataJson.featureBranchName}\"\n}, {\n  \"required\" : true,\n  \"name\" : \"recreateIfExists\",\n  \"defaultValue\" : \"{$Context.JobExecution__r.DataJson.recreateFeatureBranch}\"\n}, {\n  \"required\" : true,\n  \"name\" : \"commitMessage\",\n  \"defaultValue\" : \"{$Context.JobExecution__r.DataJson.message}\"\n}, {\n  \"required\" : true,\n  \"name\" : \"gitEmail\",\n  \"defaultValue\" : \"{$User.Email}\"\n}, {\n  \"required\" : true,\n  \"name\" : \"gitName\",\n  \"defaultValue\" : \"{$User.Name}\"\n}, {\n  \"required\" : true,\n  \"name\" : \"sourceEnvironmentBranch\",\n  \"defaultValue\" : \"{$Context.apex.SourceEnvironmentBranch}\"\n}, {\n  \"name\" : \"gitDepth\",\n  \"defaultValue\" : \"100\"\n}, {\n  \"name\" : \"timeout\",\n  \"defaultValue\" : \"180000\"\n}, {\n  \"name\" : \"chunkSize\",\n  \"defaultValue\" : \"10\"\n}, {\n  \"name\" : \"maxBuffer\",\n  \"defaultValue\" : \"5242880\"\n}, {\n  \"name\" : \"overriddenApiVersion\",\n  \"defaultValue\" : \"\"\n} ]",
                    "copado__Script__c": "#!/usr/bin/env node\n'use strict';\n\n/**\n * Performs commit of selected user story metadata changes.\n * Returns (If ACTION success) new feature branch in user repo with all the changes and returns the commit id in the result record\n * (If ACTION failed) Returns details with error status on user story commit record\n * @param fileChangesId\n * @param fileName\n * @param sourceSessionId\n * @param sourceEndPoint\n * @param git_json\n * @param baseBranch\n * @param sourceEnv\n * @param findAndReplaceFileId\n * @param featureBranch\n * @param recreateIfExists\n * @param commitMessage\n * @param gitEmail\n * @param gitName\n * @param sourceEnvironmentBranch\n * @param maxBuffer\n * @param gitDepth\n * @param timeout\n * @param chunkSize\n * @param overriddenApiVersion\n*/\n\nconst child_process = require('child_process'),\n    fs = require('fs'),\n    { featureBranch, sourceSessionId, maxBuffer, isTest, fileName, fileChangesId, findAndReplaceFileId, sourceEnv, gitDepth, baseBranch, recreateIfExists, API_VERSION, overriddenApiVersion, gitEmail, gitName } = process.env,\n    TEMP_DIRECTORY = getPath('/tmp'),\n    APP_DIRECTORY = getPath('/app'),\n    TARGET_DIRECTORY = `${APP_DIRECTORY}/repository`,\n    COMMIT_CHANGES_FILE_PATH = `${APP_DIRECTORY}/encoded_changes.json`,\n    RETRIEVE_RESULT_PATH = `${TEMP_DIRECTORY}/retrieveResult.json`,\n    FULL_PROFILE_RETRIEVE_RESULT_PATH = `${TEMP_DIRECTORY}/fullProfileResult.json`,\n    ACTIONS = {\n        ADD: 'add',\n        RETRIEVE_ONLY: 'retrieveonly',\n        FULL: 'full',\n        DELETE: 'delete'\n    },\n    TYPES = {\n        PERMISSION_SET: 'permissionset',\n        PROFILE: 'profile'\n    },\n    STDIO = {\n        INHERIT: 'inherit',\n        PIPE: 'pipe',\n        IGNORE: 'ignore'\n    },\n    PARENT_NESTED_METADATA = [\"customlabels\", \"workflow\", \"sharingrules\", \"escalationrules\", \"matchingrules\", \"autoresponserules\", \"assignmentrules\"],\n    MAXBUFFER = parseInt(maxBuffer),\n    COPADO_YML = 'Copado'\n\nlet commitChanges = {},\n    sourceApiVersion = isTest ? API_VERSION : '';\n\n// SCRIPT FUNCTIONS\n\nfunction execute() {\n    try {\n        sourceApiVersion = this.getApiVersion(overriddenApiVersion, API_VERSION);\n        const committedMetadata = this.getCommitChanges(fileChangesId, fileName);\n        this.encodeFileNames(committedMetadata, COMMIT_CHANGES_FILE_PATH);\n        commitChanges = this.prepareMetadataChangesList(COMMIT_CHANGES_FILE_PATH);\n        this.checkNestedParentMetadataDeletion(commitChanges);\n        this.fetchBaseBranch(baseBranch, gitDepth);\n        this.configureGit(gitEmail, gitName);\n        this.fetchCreateFeatureBranch(recreateIfExists, featureBranch);\n        if (commitChanges.addOrRetrieve?.length > 0 || commitChanges.profiles?.length > 0) {\n            Promise.all(this.retrieveOrgMetadata(commitChanges)).then(() => {\n                this.enrichChangeList(COMMIT_CHANGES_FILE_PATH, true);\n                this.varReplace(sourceEnv);\n                this.findAndReplace(findAndReplaceFileId, featureBranch);\n                this.processMetadata();\n                this.discardRetrieveOnlyFiles(commitChanges);\n                this.commitAndUpdateEnvironmentBranches();\n            }).catch((err) => {\n                this.executeCommand(this.getErrorCmdString(err.toString()), STDIO.INHERIT);\n                if (!isTest) {\n                    process.exit(1);\n                }\n            });\n        } else {\n            this.enrichChangeList(COMMIT_CHANGES_FILE_PATH, false);\n            this.processMetadata();\n            this.commitAndUpdateEnvironmentBranches();\n        }\n    } catch (err) {\n        this.executeCommand(this.getErrorCmdString(err.toString()), STDIO.INHERIT);\n        process.exit(1);\n    }\n}\n\n// SCRIPT FUNCTIONS\n\nfunction encodeFileNames(committedMetadata, filePath) {\n\n    this.validateCommittedChanges(committedMetadata);\n\n    for (let commitChange of committedMetadata) {\n        switch (commitChange.t) {\n            case 'DashboardFolder':\n            case 'ReportFolder':\n            case 'Document':\n                commitChange.n = commitChange.n.replace(/%2F/gi, '/');\n                break;\n\n            case 'EmailTemplate':\n                commitChange.n = commitChange.n.replace(/%24/gi, '$').replace(/%2F/gi, '/');\n                break;\n\n            case 'Layout':\n                const regExp = '(?:([a-zA-Z_][a-zA-Z0-9_]{0,14}?(?!__c-))__)?([^-]+)-(?:([a-zA-Z_][a-zA-Z0-9_]{0,14}?_?(?!__c$))__)?(.+)\\n?';\n                /*\n                    The above regExp divides the layout full name into 4 groups:\n                    1. customobject namespace\n                    2. customobject name\n                    3. layout namespace\n                    4. layout mame\n                    The match function returns these groups respectively in the indices 1,2,3,4\n                */\n                const layoutFullName = commitChange.n.match(regExp);\n                let layoutName = layoutFullName[4].replace(/_{2}(?!c)/g, (match) => { return match.replace(/_/gi, '%5F') });\n                layoutName = layoutName.replace(/\\./, '%2E');\n                commitChange.n = `${layoutFullName[1] ? layoutFullName[1] + \"__\" : \"\"}${layoutFullName[2]}-${layoutFullName[3] ? layoutFullName[3] + \"__\" : \"\"}${layoutName}`;\n                break;\n        }\n    }\n    fs.writeFileSync(filePath, JSON.stringify(committedMetadata, null, 2));\n}\n\nfunction getCommitChanges(fileChangesId, fileName) {\n    this.downloadFile(fileChangesId, `${TEMP_DIRECTORY}/`, fileName);\n    let downloadedFileName;\n    if (fs.existsSync(`${TEMP_DIRECTORY}/${fileName}`)) {\n        downloadedFileName = fileName;\n    } else if (fs.existsSync(`${TEMP_DIRECTORY}/${fileName}.json`)) {\n        downloadedFileName = `${fileName}.json`;\n    }\n    else {\n        throw 'Error fetching Commit Changes';\n    }\n    return this.readFromPath(`${TEMP_DIRECTORY}/${downloadedFileName}`);\n}\n\nfunction validateCommittedChanges(committedMetadata) {\n    const isValid = Array.isArray(committedMetadata) && committedMetadata?.length && committedMetadata?.filter(change => (!change.n || !change.t || !change.a || !change.m))?.length == 0;\n    if (!isValid) {\n        throw `The Commit Changes do not follow the Commit Action Contract`;\n    }\n}\n\nfunction prepareMetadataChangesList(filePath) {\n    let commitChanges = {};\n    commitChanges.all = this.readFromPath(filePath);\n    commitChanges = {\n        ...commitChanges,\n        addOrRetrieve: commitChanges.all.filter(selectedMetadata => (selectedMetadata.a.toLowerCase() == ACTIONS.RETRIEVE_ONLY || selectedMetadata.a.toLowerCase() == ACTIONS.ADD || (selectedMetadata.a.toLowerCase() == ACTIONS.FULL && selectedMetadata.t.toLowerCase() == TYPES.PERMISSION_SET))),\n        delete: commitChanges.all.filter(selectedMetadata => selectedMetadata.a.toLowerCase() == ACTIONS.DELETE),\n        profiles: commitChanges.all.filter(selectedMetadata => selectedMetadata.a.toLowerCase() == ACTIONS.FULL && selectedMetadata.t.toLowerCase() == TYPES.PROFILE),\n        retrieveOnly: commitChanges.all.filter(selectedMetadata => selectedMetadata.a.toLowerCase() == ACTIONS.RETRIEVE_ONLY),\n        getMetadataList(type) {\n            if (this[type]) {\n                return this[type].map(step => step.t + ':' + step.n).toString(',');\n            }\n        }\n    };\n    return commitChanges;\n}\nfunction checkNestedParentMetadataDeletion(commitChanges) {\n    const notToDeleteMetadataTypes = new Set();\n    if (commitChanges?.delete?.length) {\n        commitChanges.delete.filter(change => {\n            if (PARENT_NESTED_METADATA?.includes(change.t.toLowerCase())) {\n                notToDeleteMetadataTypes.add(change.t);\n            }\n        });\n        if (notToDeleteMetadataTypes.size) {\n            throw `${[...notToDeleteMetadataTypes].join(',')} cannot be selected for a destructive commit. Try re-committing after removing these metadata`;\n        }\n    }\n}\nfunction setup() {\n    const { sourceEndPoint } = process.env;\n    this.checkSFDXProjectJson(featureBranch, sourceApiVersion);\n    this.configureSFDXCLI(sourceApiVersion, sourceEndPoint);\n}\n\nfunction checkSFDXProjectJson(branchName, sourceApiVersion) {\n    const sfdxProjectJsonPath = `${TARGET_DIRECTORY}/sfdx-project.json`;\n    if (fs.existsSync(sfdxProjectJsonPath)) {\n        let fileContent = this.readFromPath(sfdxProjectJsonPath);\n        if (fileContent.sourceApiVersion !== sourceApiVersion) {\n            const commitMessage = `Updated sourceApiVersion from ${fileContent.sourceApiVersion} to ${sourceApiVersion} in sfdx-project.json to align the commit, promote and deploy operations with the latest supported api version of Copado`;\n            fileContent.sourceApiVersion = sourceApiVersion;\n            fs.writeFileSync(sfdxProjectJsonPath, JSON.stringify(fileContent, null, 2));\n            this.gitCommit(commitMessage, branchName);\n        }\n    } else {\n        throw `Invalid configuration in ${branchName}. sfdx-project.json is invalid or missing at project root. Copado Commit and Deploy operations are required to run from within a valid sfdx project.`;\n    }\n}\n\nfunction configureSFDXCLI(sourceApiVersion, sourceEndPoint) {\n    const baseUrl = sourceEndPoint?.substring(0, sourceEndPoint?.indexOf('/', sourceEndPoint?.indexOf('/') + 2));\n\n    const configSet = `\n    sfdx config:set instanceUrl=${baseUrl} || ${this.getErrorCmdString('Error setting instanceUrl : ' + baseUrl)}\n    sfdx config:set apiVersion=${sourceApiVersion} || ${this.getErrorCmdString('Error setting apiVersion : ' + sourceApiVersion)}`;\n    this.executeCommand(configSet, STDIO.INHERIT);\n}\n\nfunction sfdxRetrieve(commitChanges, resolve, reject) {\n\n    const retrieve = `\n        sfdx force:source:retrieve --json -u \"${sourceSessionId}\" -m '${commitChanges.getMetadataList('addOrRetrieve')}' || true\n    `;\n    child_process.exec(retrieve, { stdio: STDIO.INHERIT, maxBuffer: MAXBUFFER }, (err, retrieveResult, stderr) => {\n        // Adding the retrive result to the logs\n        retrieveResult = JSON.parse(retrieveResult.toString());\n        if (retrieveResult.status && retrieveResult.message) {\n            reject(retrieveResult.message);\n            return;\n        }\n\n        const failedMetadataList = retrieveResult?.result?.inboundFiles?.filter(file => file.state == 'Failed');\n\n        if (failedMetadataList?.length) {\n            const err = failedMetadataList.map(metadata => metadata.error).toString();\n            reject(err);\n            return;\n        }\n        fs.writeFileSync(RETRIEVE_RESULT_PATH, JSON.stringify(retrieveResult));\n        this.uploadFile(RETRIEVE_RESULT_PATH);\n        resolve(retrieveResult);\n    });\n}\n\nfunction retrieveFullProfile(commitChanges, resolve, reject) {\n\n    const retrieveFullProfile = `\n        sfdx sfpowerkit:source:profile:retrieve -u \"${sourceSessionId}\" -n \"${commitChanges.profiles.map(profile => profile.n).toString()}\" --json\n        `\n    child_process.exec(retrieveFullProfile, { stdio: STDIO.INHERIT }, (err, response, stderr) => {\n        const profileResult = response && JSON.parse(response.toString());\n        if (err) {\n            if (profileResult && profileResult.status && profileResult.message) {\n                reject(profileResult.message);\n                return;\n            }\n            reject(\"Full Profile Retrieval Failed\");\n        } else {\n            fs.writeFileSync(FULL_PROFILE_RETRIEVE_RESULT_PATH, JSON.stringify(profileResult));\n            fs.rmSync(\"sfpowerkit-cache.db\", {\n                force: true,\n            });\n            resolve();\n        }\n    });\n}\nfunction retrieveOrgMetadata(commitChanges) {\n\n    this.setup();\n    const setProgress = `\n    copado -p \"Retrieving the selected metadata\"`\n    this.executeCommand(setProgress);\n    const promises = [];\n    commitChanges.profiles?.length && promises.push(new Promise((resolve, reject) => {\n        this.retrieveFullProfile(commitChanges, resolve, reject);\n    }));\n    commitChanges.addOrRetrieve?.length && promises.push(new Promise((resolve, reject) => {\n        this.sfdxRetrieve(commitChanges, resolve, reject);\n    }));\n    return promises;\n}\n\nfunction varReplace(sourceEnv) {\n    const filesToIncludeListPath = `${TEMP_DIRECTORY}/filesToInclude.json`,\n        filesToInclude = this.getFilesInScope();\n    if (filesToInclude?.length && sourceEnv && JSON.parse(sourceEnv)?.length) {\n        fs.writeFileSync(filesToIncludeListPath, JSON.stringify(filesToInclude));\n        const varreplace = `\n            copado -p \"Replacing environment variables, if any\"\n            varreplace '${sourceEnv}' '${TARGET_DIRECTORY}' --valuename=true  --include=${filesToIncludeListPath} || ${this.getErrorCmdString(\"Error replacing environment variables\")}`;\n        this.executeCommand(varreplace, STDIO.INHERIT);\n    }\n}\n\nfunction getFilesInScope() {\n    let filesInScope = [];\n    if (fs.existsSync(RETRIEVE_RESULT_PATH)) {\n        const retrieveResult = this.readFromPath(RETRIEVE_RESULT_PATH);\n        filesInScope = retrieveResult?.result?.inboundFiles?.map(file => file.filePath.substring(TARGET_DIRECTORY.length + 1));\n    };\n    if (fs.existsSync(FULL_PROFILE_RETRIEVE_RESULT_PATH)) {\n        const profileResult = this.readFromPath(FULL_PROFILE_RETRIEVE_RESULT_PATH);\n        if (profileResult) {\n            profileResult?.result?.forEach(fileChange => {\n                if (fileChange.state !== 'Skipped') {\n                    filesInScope.push(fileChange.path);\n                }\n            });\n        }\n    }\n    const retrieveOnlyFilePaths = this.getFilePaths(COMMIT_CHANGES_FILE_PATH, [ACTIONS.RETRIEVE_ONLY]);\n    if (retrieveOnlyFilePaths?.length && filesInScope?.length) {\n        filesInScope = filesInScope.filter(file => !(retrieveOnlyFilePaths.includes(file)));\n    }\n    return filesInScope;\n}\n\nfunction fetchBranch(branch, gitDepth) {\n    let fetchBranch = 'copado-git-get';\n    fetchBranch += gitDepth ? ` --depth \"${gitDepth}\"` : ``;\n    fetchBranch += ` \"${branch}\" || ${this.getErrorCmdString(\"Error fetching \" + branch)}`;\n    this.executeCommand(fetchBranch, STDIO.INHERIT);\n}\n\nfunction fetchBaseBranch(baseBranch, gitDepth) {\n\n    const createDirectory = `mkdir -p ${TARGET_DIRECTORY}`;\n    this.executeCommand(createDirectory, STDIO.INHERIT);\n\n    process.chdir(TARGET_DIRECTORY);\n\n    if (!baseBranch) {\n        throw 'No base branch provided';\n    }\n\n    this.fetchBranch(baseBranch, gitDepth);\n}\n\nfunction fetchCreateFeatureBranch(recreateIfExists, featureBranch) {\n\n    if (featureBranch) {\n        if (recreateIfExists == 'true') {\n            const deleteLocalAndRemoteBranch = `\n            copado -p \"Removing branch ${featureBranch}\"\n            git branch -D \"${featureBranch}\" || true\n            git push origin --delete \"${featureBranch}\" || true`\n            this.executeCommand(deleteLocalAndRemoteBranch, STDIO.INHERIT);\n        }\n        const fetchCreateFeatureBranch = `copado -p \"Fetching/creating branch ${featureBranch}\"\n        copado-git-get -c \"${featureBranch}\" ||  ${this.getErrorCmdString(\"Error fetching/creating \" + featureBranch)}`;\n        this.executeCommand(fetchCreateFeatureBranch, STDIO.INHERIT);\n    } else {\n        throw 'No feature branch provided';\n    }\n}\n\nfunction findAndReplace(findAndReplaceFileId, featureBranch) {\n    const PATH_TO_YAML = `${TEMP_DIRECTORY}/${COPADO_YML}`;\n    if (findAndReplaceFileId) {\n        this.executeCommand(`copado -p \"Applying global find and replace rules\"`);\n        this.downloadFile(findAndReplaceFileId, `${TEMP_DIRECTORY}/`, COPADO_YML);\n        if (fs.existsSync(PATH_TO_YAML)) {\n            const findAndReplace = `yamlreplace \"${PATH_TO_YAML}\" \"${TARGET_DIRECTORY}\" -b \"${featureBranch}\" ||  ${this.getErrorCmdString(\"Error applying find and replace rules\")}`;\n            this.executeCommand(findAndReplace, STDIO.INHERIT);\n        } else {\n            throw 'Could not find the Copado.yml file';\n        }\n\n    }\n}\n\nfunction enrichChangeList(filePath, includeCliResponse) {\n    this.executeCommand(`enricher -p ${filePath} --repo ${TARGET_DIRECTORY}/ ${includeCliResponse ? (fs.existsSync(RETRIEVE_RESULT_PATH) ? '--cliresponse ' + RETRIEVE_RESULT_PATH : '') : ' '} || ${this.getErrorCmdString(\"Error finding file paths for the committed changes\")}`, STDIO.INHERIT);\n}\n\nfunction processMetadata() {\n    const pocesssMetadata = `\n            copado -p \"Processing metadata\"\n            metadata-processor \"${COMMIT_CHANGES_FILE_PATH}\" \"${TARGET_DIRECTORY}\" -o COMMIT ||  ${this.getErrorCmdString(\"Error processing metadata\")}\n        `;\n    this.executeCommand(pocesssMetadata, STDIO.INHERIT);\n}\n\nfunction gitCommit(commitMessage, branchName) {\n    const gitCommit = `\n    copado -p \"Committing ${commitMessage} in ${branchName}\"\n    git add . || ${this.getErrorCmdString(\"There was some issue when staging changes\")}\n    git commit -m \"${commitMessage}\" || ${this.getErrorCmdString(\"There was some issue when committing changes\")}\n    `;\n    this.executeCommand(gitCommit, STDIO.INHERIT);\n}\n\nfunction configureGit(gitEmail, gitName) {\n    const configureGit = `\n        git config --local user.email \"${gitEmail}\" || ${this.getErrorCmdString('Failure in configuring git user email')}\n        git config --local user.name \"${gitName}\" || ${this.getErrorCmdString('Failure in configuring git user name')}\n        git config --global diff.renames false || ${this.getErrorCmdString('Failure in disabling git rename detection from diff.renames')}\n        git config --global merge.renames false || ${this.getErrorCmdString('Failure in disabling git rename detection from merge.renames')}\n        git config --global status.renames false || ${this.getErrorCmdString('Failure in disabling git rename detection from status.renames')}\n        `;\n    this.executeCommand(`${configureGit}`, STDIO.INHERIT);\n}\n\nfunction commitAndUpdateEnvironmentBranches() {\n    const resultData = {};\n    const { commitMessage, sourceEnvironmentBranch } = process.env,\n        gitStatus = this.executeCommand(`\n    git status --porcelain`);\n    if (!gitStatus) {\n        resultData.status = \"No Changes\";\n        this.executeCommand(`copado -p \"There are no changes to be committed\" -r '${JSON.stringify(resultData)}' && exit 0`);\n    }\n    else {\n\n        this.gitCommit(commitMessage, featureBranch);\n        this.gitPush(featureBranch);\n\n        this.saveCommitDetails(resultData);\n\n        this.fetchBranch(sourceEnvironmentBranch);\n        this.mergeFeatureBranchInSource(featureBranch, sourceEnvironmentBranch);\n\n        this.checkSFDXProjectJson(sourceEnvironmentBranch, sourceApiVersion);\n\n        this.gitPush(sourceEnvironmentBranch);\n    }\n}\n\n\nfunction mergeFeatureBranchInSource(featureBranch, sourceEnvironmentBranch) {\n    if (!sourceEnvironmentBranch) {\n        throw 'No source environment branch provided';\n    }\n    const mergeFeatureBranchInSource = `\n    copado -p \"Merging changes to source branch - ${sourceEnvironmentBranch}\"\n\n    # We have used || true with git merge because:\n    # 1. We do not want this command to fail. After merge, if there is a conflict, we only want to find the git status after the merge and send it to the copado-merge service and they will handle the conflicts for us.\n    # 2. If we fail this command on a conflict, then we will not be able to send control to the copado-merge service.\n    git merge \"${featureBranch}\" -Xignore-space-change || true\n    copado -p \"Resolving git conflicts, if any\"\n    git status --porcelain=v1 > ${TEMP_DIRECTORY}/git_status.txt\n    echo \"Git Status:\"\n    cat ${TEMP_DIRECTORY}/git_status.txt\n    touch ${TEMP_DIRECTORY}/output.json\n    copado-merge ${TARGET_DIRECTORY} ${COMMIT_CHANGES_FILE_PATH} -p ${TEMP_DIRECTORY}/git_status.txt -t sfdx -c --out ${TEMP_DIRECTORY}/ ||  ${this.getErrorCmdString(\"There was some issue merging \" + featureBranch + \" into \" + sourceEnvironmentBranch)}\n    git add . || ${getErrorCmdString('There was some issue staging the changes on ' + sourceEnvironmentBranch)}\n    git commit -am \"Merging ${featureBranch} into ${sourceEnvironmentBranch} after auto conflict resolution\"|| true`;\n\n    this.executeCommand(mergeFeatureBranchInSource, STDIO.INHERIT);\n}\n\nfunction getCommitId() {\n    return this.executeCommand(`git rev-parse HEAD || ${getErrorCmdString('There was some issue finding the commitid')}`);\n}\n\nfunction saveCommitDetails(resultData) {\n    resultData.commitId = this.getCommitId();\n    this.executeCommand(`copado -p 'Saving commit details' --result-data '${JSON.stringify(resultData)}'  || ${this.getErrorCmdString('Error saving commit details')}`);\n}\n\nfunction gitPush(branchName) {\n    const gitPush = `\n    copado -p \"Pushing all changes to ${branchName}\"\n    git push origin \"${branchName}\" ||  ${this.getErrorCmdString(\"Could not push the changes\")}\n    `;\n    this.executeCommand(gitPush, STDIO.INHERIT);\n}\n\nfunction getErrorCmdString(error) {\n    const suffix = 'Please check the logs for details.'\n    return `{ copado -p 'Error' -e '${error}. ${suffix}'; exit 1; }`\n}\n\nfunction readFromPath(filePath) {\n    if (!fs.existsSync(filePath)) {\n        throw `Could not find file at path: ${filePath}`;\n    }\n    const data = fs.readFileSync(filePath, 'utf-8');\n    let result;\n    try {\n        result = JSON.parse(data);\n    }\n    catch (err) {\n        throw `Content at ${filePath} is not a valid JSON`;\n    }\n    return result;\n}\n\nfunction getFilePaths(changeFilePath, actions) {\n    let changeList = this.readFromPath(changeFilePath);\n    let filePaths = new Set();\n    if (actions?.length) {\n        changeList = changeList.filter(change => actions.includes(change.a.toLowerCase()));\n    };\n    changeList.forEach(change => {\n        if (change.j && change.j !== '') {\n            const filesToBeAdded = (JSON.parse(change.j)?.filePath)?.filter(file => fs.existsSync(file) && fs.statSync(file).isFile());\n            if (filesToBeAdded) {\n                filePaths = new Set([...filePaths, ...filesToBeAdded]);\n            }\n        }\n    });\n    return [...filePaths];\n}\n\nfunction discardRetrieveOnlyFiles(commitChanges) {\n    if (commitChanges.retrieveOnly?.length) {\n        const retrieveChangesPath = `${TEMP_DIRECTORY}/retrieveOnlyFiles.json`;\n        fs.writeFileSync(retrieveChangesPath, JSON.stringify(commitChanges.retrieveOnly));\n        this.enrichChangeList(retrieveChangesPath, false);\n        this.discardFilesInGit(this.getFilePaths(retrieveChangesPath));\n    }\n}\n\nfunction getUntrackedFiles() {\n    const untrackedFiles = this.executeCommand(`git ls-files --others --exclude-standard || ${getErrorCmdString('There was some issue finding the untracked files')}`)?.split('\\n')?.map(file => file?.trim())?.filter(file => file != '');\n    return untrackedFiles;\n}\n\nfunction executeCommandinChunks(fileList, cmd) {\n    const { chunkSize } = process.env;\n    if (fileList.length > 0) {\n        let fileIndex = 0;\n        do {\n            let endIndex = fileIndex + parseInt(chunkSize) > fileList.length ? fileList.length : fileIndex + parseInt(chunkSize);\n            let fileChunk = fileList.slice(fileIndex, endIndex);\n            this.executeCommand(cmd.replace(/REPLACE_VALUE/g, fileChunk.map(file => `'${file}'`).join(' ')));\n            fileIndex = endIndex;\n        } while (fileIndex < fileList.length);\n    }\n}\n\nfunction discardFilesInGit(fileList) {\n    const addedFiles = this.getFilePaths(COMMIT_CHANGES_FILE_PATH, [ACTIONS.ADD]);\n    if (addedFiles?.length) {\n        fileList = fileList.filter(file => !(addedFiles.includes(file)));\n    }\n    const unTrackedFiles = this.getUntrackedFiles();\n    const toBeCleanedFiles = fileList.filter(file => unTrackedFiles.includes(file));\n    const trackedFiles = fileList.filter(file => !(toBeCleanedFiles.includes(file)));\n    toBeCleanedFiles?.length && this.executeCommandinChunks(toBeCleanedFiles, `git clean -fd REPLACE_VALUE`);\n    trackedFiles?.length && this.executeCommandinChunks(trackedFiles, `( git checkout HEAD -- REPLACE_VALUE ) || true`);\n}\n\nfunction executeCommand(cmd, ioconfig) {\n    const options = {\n        shell: true,\n        maxBuffer: MAXBUFFER\n    };\n    if (ioconfig) {\n        options.stdio = ioconfig;\n    }\n    const response = child_process.spawnSync(cmd, options);\n    if (response?.status != 0) {\n        if (response?.status == 1) {\n            if (isTest) {\n                throw response?.stdout?.toString();\n            }\n            process.exit(1);\n        }\n        if (response?.stderr) {\n            throw response?.stderr;\n        }\n    }\n    return response?.stdout?.toString()?.trim();\n}\n\nfunction getApiVersion(overriddenApiVersion, apiVersion) {\n    const finalApiVersion = overriddenApiVersion || apiVersion;\n    const regExpApiVersion = /\\d\\d\\.0/;\n    if (!(regExpApiVersion.test(finalApiVersion))) {\n        this.executeCommand(this.getErrorCmdString(`Invalid API Version: ${finalApiVersion}`));\n    }\n    return finalApiVersion;\n}\n\nfunction getPath(filePath) {\n    return isTest ? `${__dirname}/__tests__/__mockDir__${filePath}` : filePath;\n}\n\nfunction uploadFile(filePath) {\n    this.executeCommand(`copado --uploadfile ${filePath} || ${this.getErrorCmdString('Error uploading file at filePath: ' + filePath)}`, STDIO.INHERIT);\n}\n\nfunction downloadFile(fileId, downloadDir, fileName) {\n    this.executeCommand(`copado --downloadfiles ${fileId} --downloaddir ${downloadDir} || ${getErrorCmdString('Error downloading file ' + fileName)}`, STDIO.INHERIT);\n}\n\nmodule.exports.encodeFileNames = encodeFileNames\nmodule.exports.getCommitChanges = getCommitChanges\nmodule.exports.executeCommand = executeCommand\nmodule.exports.discardFilesInGit = discardFilesInGit\nmodule.exports.getUntrackedFiles = getUntrackedFiles\nmodule.exports.executeCommandinChunks = executeCommandinChunks\nmodule.exports.discardRetrieveOnlyFiles = discardRetrieveOnlyFiles\nmodule.exports.getFilePaths = getFilePaths\nmodule.exports.readFromPath = readFromPath\nmodule.exports.getErrorCmdString = getErrorCmdString\nmodule.exports.gitPush = gitPush\nmodule.exports.saveCommitDetails = saveCommitDetails\nmodule.exports.getCommitId = getCommitId\nmodule.exports.commitAndUpdateEnvironmentBranches = commitAndUpdateEnvironmentBranches\nmodule.exports.processMetadata = processMetadata\nmodule.exports.gitCommit = gitCommit\nmodule.exports.enrichChangeList = enrichChangeList\nmodule.exports.findAndReplace = findAndReplace\nmodule.exports.execute = execute\nmodule.exports.fetchCreateFeatureBranch = fetchCreateFeatureBranch\nmodule.exports.fetchBaseBranch = fetchBaseBranch\nmodule.exports.getFilesInScope = getFilesInScope\nmodule.exports.varReplace = varReplace\nmodule.exports.retrieveOrgMetadata = retrieveOrgMetadata\nmodule.exports.retrieveFullProfile = retrieveFullProfile\nmodule.exports.sfdxRetrieve = sfdxRetrieve\nmodule.exports.configureSFDXCLI = configureSFDXCLI\nmodule.exports.checkSFDXProjectJson = checkSFDXProjectJson\nmodule.exports.setup = setup\nmodule.exports.checkNestedParentMetadataDeletion = checkNestedParentMetadataDeletion\nmodule.exports.prepareMetadataChangesList = prepareMetadataChangesList\nmodule.exports.configureGit = configureGit\nmodule.exports.getApiVersion = getApiVersion\nmodule.exports.validateCommittedChanges = validateCommittedChanges\nmodule.exports.uploadFile = uploadFile\nmodule.exports.downloadFile = downloadFile\nmodule.exports.mergeFeatureBranchInSource = mergeFeatureBranchInSource\nmodule.exports.fetchBranch = fetchBranch\n\n\n\n// EXECUTION\n\n!isTest && this.execute();",
                    "copado__Type__c": "Standard",
                    "copado__Version__c": "1",
                    "Id": "a0l7Q000000MDYwQAO",
                    "copado__Worker_Size__c": "M",
                    "LastReferencedDate": "2023-02-07T07:06:57.000+0000",
                    "LastViewedDate": "2023-02-07T07:06:57.000+0000",
                    "Name": "Commit"
                },
                {
                    "attributes": {
                        "type": "copado__Function__c",
                        "url": "/services/data/v56.0/sobjects/copado__Function__c/a0l7Q000000MDYxQAO"
                    },
                    "copado__API_Name__c": "sfdx_promote",
                    "copado__Callback_Type__c": "Flow",
                    "copado__Description__c": "Creation of Promotion Branch and Promotion of user stories",
                    "copado__FlowHandler__c": "cmcSf.Update_Conflict_Resolution_File",
                    "copado__Image_Name__c": "copado-multicloud-dx:v3",
                    "copado__Options__c": "[ ]",
                    "copado__Parameters__c": "[ {\n  \"required\" : true,\n  \"name\" : \"user_stories\",\n  \"defaultValue\" : \"{$Context.JobExecution__r.DataJson.userStoryBranches}\"\n}, {\n  \"required\" : true,\n  \"name\" : \"promotion_branch\",\n  \"defaultValue\" : \"{$Context.JobExecution__r.DataJson.promotionBranchName}\"\n}, {\n  \"required\" : true,\n  \"name\" : \"target_branch\",\n  \"defaultValue\" : \"{$Context.JobExecution__r.DataJson.destinationBranchName}\"\n}, {\n  \"required\" : false,\n  \"name\" : \"tag\",\n  \"defaultValue\" : \"{$Context.JobExecution__r.Promotion__r.Release__r.Version__c}\"\n}, {\n  \"required\" : true,\n  \"name\" : \"git_json\",\n  \"defaultValue\" : \"{$Context.Repository.Credential}\"\n}, {\n  \"required\" : false,\n  \"name\" : \"recreatePromotionBranch\",\n  \"defaultValue\" : \"{$Context.JobExecution__r.Promotion__r.cmcSf__Recreate_Promotion_Branch__c}\"\n}, {\n  \"name\" : \"promotion_id\",\n  \"defaultValue\" : \"{$Job.ExecutionParent.Id}\"\n}, {\n  \"name\" : \"file_changes_id\",\n  \"defaultValue\" : \"{$Context.JobExecution__r.DataJson.fileWithSelectedChanges}\"\n}, {\n  \"name\" : \"conflict_resolution_attachments\",\n  \"defaultValue\" : \"{$Context.apex.GetConflictResolutionAttachments}\"\n}, {\n  \"name\" : \"git_name\",\n  \"defaultValue\" : \"{$User.Name}\"\n}, {\n  \"name\" : \"git_email\",\n  \"defaultValue\" : \"{$User.Email}\"\n}, {\n  \"name\" : \"repository_id\",\n  \"defaultValue\" : \"{$Pipeline.Git_Repository__r.Id}\"\n}, {\n  \"required\" : true,\n  \"name\" : \"git_depth\",\n  \"defaultValue\" : \"100\"\n}, {\n  \"name\" : \"maxBuffer\",\n  \"defaultValue\" : \"5242880\"\n}, {\n  \"name\" : \"file_name\",\n  \"defaultValue\" : \"Copado Promotion changes\"\n}, {\n  \"name\" : \"overriddenApiVersion\",\n  \"defaultValue\" : \"\"\n} ]",
                    "copado__Script__c": "#!/usr/bin/env node\n\n\n\n/**\n * Performs promotion of selected user story metadata changes.\n * Returns (If ACTION success) new peomotion branch in user repo with all the changes\n * (If ACTION failed) Returns details with conflict or error status on promotion record\n * @param user_stories\n * @param promotion_branch\n * @param target_branch\n * @param tag\n * @param recreatePromotionBranch\n * @param promotion_id\n * @param file_changes_id\n * @param conflict_resolution_attachments\n * @param git_name\n * @param git_email\n * @param repository_id\n * @param git_depth\n * @param maxBuffer\n*/\n\nconst { spawnSync } = require('child_process'),\n    { existsSync, readFileSync, writeFileSync } = require('fs'),\n    { exit, env, chdir } = require('process');\n\nconst {\n    file_changes_id,\n    target_branch,\n    promotion_branch,\n    git_depth,\n    git_email,\n    git_name,\n    promotion_id,\n    repository_id,\n    conflict_resolution_attachments,\n    user_stories,\n    tag,\n    recreatePromotionBranch,\n    maxBuffer,\n    file_name,\n    overriddenApiVersion,\n    API_VERSION\n} = env,\nMAXBUFFER = parseInt(maxBuffer),\nSTDIO = {\n    INHERIT: 'inherit',\n    PIPE: 'pipe'\n},\nTARGET_DIRECTORY = '/app/repository',\nOUTPUT_JSON_PATH = '/tmp/output.json',\nGIT_STATUS_FILE_PATH = '/tmp/git_status.txt',\nENRICHED_CHANGE_FILE_PATH = '/tmp/enrichedPromotionChanges.json',\nSOURCE_API_VERSION = getApiVersion();\n\nlet promotionChangesFilePath;\n\n// EXECUTION\n\nexecute();\n\nfunction execute() {\n\n    try {\n        getPromotionChanges();\n        fetchTargetBranch();\n        configureGit();\n        fetchCreatePromotionBranch();\n        checkSFDXProjectJson();\n        promote();\n        gitPush();\n    } catch (err) {\n        executeCommand(`copado -p 'Error' -e \"${err.toString()}\"`);\n        exit(1);\n    }\n}\n\n// SCRIPTS\n\nfunction getPromotionChanges() {\n    executeCommand(`copado --downloadfiles ${file_changes_id} --downloaddir /tmp/`);\n    if(existsSync(`/tmp/${file_name}`)) {\n        promotionChangesFilePath =  `/tmp/${file_name}`;\n    } else if(existsSync(`/tmp/${file_name}.json`)) {\n        promotionChangesFilePath = `/tmp/${file_name}.json`;\n    }\n    else {\n        throw 'Error fetching Promotion Changes';\n    }\n}\n\nfunction fetchTargetBranch() {\n\n    let dirSetupCommand = `\n        rm -rf ${TARGET_DIRECTORY}\n        mkdir ${TARGET_DIRECTORY}\n    `\n    executeCommand(dirSetupCommand);\n    chdir(TARGET_DIRECTORY);\n\n    let command = `\n    copado-git-get --depth \"${git_depth ? git_depth : 100}\" \"${target_branch}\" || ${getErrorStringAndExit(\"Error fetching branch \" + target_branch)}`;\n    executeCommand(command);\n}\n\nfunction fetchCreatePromotionBranch() {\n\n    let command = `\n        if [ -n \"${promotion_branch}\" ]; then\n            if [ ${recreatePromotionBranch} == \"true\" ]; then\n            exists=$(git ls-remote --heads origin ${promotion_branch} | wc -l)\n                if [ -n \"$exists\" ]; then\n                    copado -p \"Removing branch ${promotion_branch}\"\n                    git push origin --delete \"${promotion_branch}\" || true\n                fi\n            fi\n            copado -p \"Fetching/creating branch ${promotion_branch}\"\n            copado-git-get -c \"${promotion_branch}\" ||  ${getErrorStringAndExit(\"Error fetching/creating branch\" + promotion_branch)}\n        fi\n    `;\n    executeCommand(command);\n}\nfunction configureGit(){\n    executeCommand(`\n        git config --local user.email \"${git_email}\" || exit 1\n        git config --local user.name \"${git_name}\" || exit 1\n        git config --global diff.renames false || exit 1\n        git config --global merge.renames false || exit 1\n        git config --global status.renames false || exit 1\n    `);\n}\n\nfunction promote() {\n\n    let gitConflictsResolution = [];\n    for(let story of JSON.parse(user_stories)) {\n        if(story.indexOf('/') === -1) {\n            throw `User Story branch - ${story} does not follow the Copado Branching strategy`;\n         }\n        let userStoryName = story.split('/')[1];\n        const fetchStory = `copado -p \"Merging ${story} into ${promotion_branch}\"\n        copado-git-get --depth \"${git_depth ? git_depth : 100}\" \"${story}\" ||  ${getErrorStringAndExit(\"Error fetching branch \" + story)}`;\n\n        executeCommand(fetchStory);\n\n\n        const mergeFeatureBranchInPromotionBranch = `\n            git checkout \"${promotion_branch}\" ||  ${getErrorStringAndExit(\"Error fetching branch \" + promotion_branch)}\n            git merge -m \"Merging ${story} to ${promotion_branch}\" \"${story}\" -Xignore-space-change || true\n            copado -p \"Resolving git conflicts, if any\"\n            git status --porcelain=v1 > ${GIT_STATUS_FILE_PATH}\n            `;\n\n        executeCommand(mergeFeatureBranchInPromotionBranch);\n        let output;\n        if(hasConflict()) {\n            resolveConflict(userStoryName);\n            if(existsSync(OUTPUT_JSON_PATH)) {\n                output = JSON.parse(readFileSync(OUTPUT_JSON_PATH, 'utf8'));\n                if(output?.some(file =>  file.strategy === \"ONLINE_CONFLICT_RESOLUTION\")) {\n                    executeCommand(`copado -p \"Conflict found while merging ${story} to $promotion_branch. Conflict needs to be resolved manually.\" -r '{\"status\": \"conflicts\"}'\n                        exit 1`);\n                }\n            }\n        }\n        gitCommit(`Merging ${story} to ${promotion_branch} after auto conflict resolution`);\n        if(output?.length) {\n            gitConflictsResolution.push(...(saveMergeCommitId(output)));\n        }\n\n    }\n    uploadGitConflictsResolution(gitConflictsResolution);\n}\nfunction uploadGitConflictsResolution(gitConflictsResolution){\n    if(gitConflictsResolution?.length) {\n        const conflictResolutionsFilePath = '/tmp/GitConflictsResolution.json';\n        writeFileSync(conflictResolutionsFilePath, JSON.stringify(gitConflictsResolution, null, 2));\n        executeCommand(`copado --uploadfile ${conflictResolutionsFilePath}`);\n    }\n}\nfunction hasConflict() {\n    const options = {\n        shell: true,\n        stdio: STDIO.INHERIT\n    }\n    return spawnSync(`${getCopadoMergeCommand()}  check-conflict`, options)?.status;\n}\n\nfunction getCopadoMergeCommand() {\n    return `copado-merge ${TARGET_DIRECTORY} '${promotionChangesFilePath}' -p ${GIT_STATUS_FILE_PATH} -t sfdx -cp ${promotion_id} -rp ${repository_id}`;\n}\n\n\nfunction resolveConflict(userStoryName) {\n    const CONFLICTED_CHANGES = '/tmp/conflictedChanges';\n    writeFileSync(CONFLICTED_CHANGES, getConflictingFilePaths().join('\\n'), 'utf-8');\n\n    const enrichMetadataList = `enricher --changefile ${CONFLICTED_CHANGES} --repo ${TARGET_DIRECTORY}/  --out ${ENRICHED_CHANGE_FILE_PATH} || ${getErrorStringAndExit(\"Error finding file paths for the promoted changes\")}`;\n    executeCommand(enrichMetadataList);\n\n    executeCommand(`\n    echo \"${JSON.stringify(conflict_resolution_attachments)}\" > /tmp/solvedByUser.json\n    touch ${OUTPUT_JSON_PATH}`);\n\n    executeCommand(`${getCopadoMergeCommand()} -r /tmp/solvedByUser.json  -u ${userStoryName}  --out /tmp -v2 --conflictedchanges '${ENRICHED_CHANGE_FILE_PATH}' ||  ${getErrorStringAndExit(\"Error processing merge\")}`);\n}\n\nfunction getConflictingFilePaths() {\n        const lines = readFileSync(GIT_STATUS_FILE_PATH,'utf-8')?.split('\\n');\n        const conflictedFiles = [];\n        if(lines?.length) {\n            lines.forEach(line => {\n                if(line) {\n                    const space = line.indexOf(' ');\n                    const conflictType = line.substring(0, space);\n                    const filePath = line.substring(space + 1).replaceAll(/^\\\"|\\\"$/g, '');\n                     if (filePath && conflictType.length == 2 && !conflictType.includes('?')) {\n                        conflictedFiles.push(filePath);\n                     }\n                }\n            });\n        }\n        // throwing an error when the backend service responds that the merge has conflict, but the git status does not provide the paths\n        if(!conflictedFiles?.length) {\n            throw 'Could not find conflicting files';\n        }\n        return conflictedFiles;\n}\n \nfunction gitCommit(commitMessage) {\n    executeCommand(`\n        git add . # add all the resolved changes, if any \n        git commit -am \"${commitMessage}\" || true`);\n}\n\nfunction saveMergeCommitId(output) {\n    const mergeCommitId = executeCommand(`git rev-parse HEAD`, STDIO.PIPE)?.trim();\n    output.map(file => file.sucessfulPromotion = mergeCommitId);\n    return output;\n}\n\nfunction gitPush(){\n    executeCommand(`\n        copado -p \"Pushing all changes\"\n        if [ -n \"${tag}\" ]; then\n            git tag \"${tag}\"\n            git push --all || ${getErrorStringAndExit(\"Could not push the changes\")}\n        else\n            echo \"No tag specified\"\n            git push origin \"${promotion_branch}\" || ${getErrorStringAndExit(\"Could not push the changes\")}\n        fi\n    `);\n}\n\nfunction checkSFDXProjectJson() {\n    const sfdxProjectJsonPath = `${TARGET_DIRECTORY}/sfdx-project.json`;\n    if(existsSync(sfdxProjectJsonPath)) {\n        let fileContent = JSON.parse(readFileSync(sfdxProjectJsonPath, { encoding:'utf8' }));\n        if(fileContent.sourceApiVersion !== SOURCE_API_VERSION) {\n            const commitMessage = `Updated  sourceApiVersion from ${fileContent.sourceApiVersion} to ${SOURCE_API_VERSION} in sfdx-project.json to align the commit, promote and deploy operations with the latest supported api version of Copado.`;\n            fileContent.sourceApiVersion = SOURCE_API_VERSION;\n            writeFileSync(sfdxProjectJsonPath, JSON.stringify(fileContent, null, 2));\n            gitCommit(commitMessage);\n        }\n    } else {\n        throw \"Invalid configuration. sfdx-project.json is invalid or missing at project root. Copado Commit and Deploy operations are required to run from within a valid sfdx project.\";\n    }\n}\n\nfunction getErrorStringAndExit(err) {\n    const suffix = \"Please check the logs for details.\"\n    return  `{ copado -p \"Error\" -e \"${err}. ${suffix}\"; exit 1; }`;\n}\n\nfunction executeCommand(cmd, ioconfig) {\n    const options = {\n         shell: true,\n         maxBuffer:  MAXBUFFER\n    };\n    if(ioconfig) {\n        options.stdio = ioconfig;\n    }\n    else {\n        options.stdio = STDIO.INHERIT;\n    }\n    const response = spawnSync(cmd, options);\n    if(response?.status != 0) {\n        if(response?.status == 1) {\n            exit(1);\n        }\n        if(response?.stderr) {\n            throw response?.stderr;\n        }\n    }\n    return response?.stdout?.toString();\n}\n\nfunction getApiVersion() {\n    const finalApiVersion = overriddenApiVersion || API_VERSION;\n    const regExpApiVersion = /\\d\\d\\.0/;\n    if(!(regExpApiVersion.test(finalApiVersion))) {\n        executeCommand(getErrorStringAndExit('Invalid API Version'));\n    }\n    return finalApiVersion;\n}",
                    "copado__Type__c": "Standard",
                    "copado__Worker_Size__c": "M",
                    "Id": "a0l7Q000000MDYxQAO",
                    "LastReferencedDate": "2022-12-20T12:38:37.000+0000",
                    "LastViewedDate": "2022-12-20T12:38:37.000+0000",
                    "Name": "Promote"
                },
                {
                    "attributes": {
                        "type": "copado__Function__c",
                        "url": "/services/data/v55.0/sobjects/copado__Function__c/a0l7Q000000MDYyQAO"
                    },
                    "copado__API_Name__c": "sfdx_encode_file_names",
                    "copado__Image_Name__c": "copado-multicloud-dx:v3",
                    "copado__Options__c": "[ ]",
                    "copado__Parameters__c": "[ {\n  \"name\" : \"file_changes_id\",\n  \"defaultValue\" : \"{$Context.JobExecution__r.DataJson.fileWithSelectedChanges}\"\n}, {\n  \"name\" : \"file_name\",\n  \"defaultValue\" : \"Copado Deploy changes\"\n} ]",
                    "copado__Script__c": "#!/usr/bin/env node\nconst execSync = require('child_process').execSync,\n    { existsSync, writeFileSync, readFileSync } = require('fs');\n\nlet deploymentMetadata = [];\n\n// EXECUTION\n\nexecute();\n\nfunction execute() {\n    getDeployChanges();\n    encodeFileNames();\n}  \n\n// SCRIPT FUNCTIONS\n\nfunction getDeployChanges() {\n    const { file_name, file_changes_id } = process.env;\n    execSync(`copado --downloadfiles ${file_changes_id} --downloaddir /tmp/`);\n    let downloadedFileName;\n    if(existsSync(`/tmp/${file_name}`)) {\n        downloadedFileName = file_name;\n    } else if(existsSync(`/tmp/${file_name}.json`)) {\n        downloadedFileName = `${file_name}.json`;\n    }\n    else {\n        throw 'Error fetching Deployment Changes';\n    }\n    deploymentMetadata = readFromPath(`/tmp/${downloadedFileName}`);\n}\nfunction encodeFileNames() {\n    console.log(deploymentMetadata);\n    for (let change of deploymentMetadata) { \n        switch (change.t) {\n            case 'DashboardFolder':\n            case 'ReportFolder':\n            case 'Document':\n                change.n = change.n.replace(/%2F/gi, '/');\n                break;\n\n            case 'EmailTemplate':\n                change.n = change.n.replace(/%24/gi, '$').replace(/%2F/gi, '/');\n                break;\n \n            case 'Layout':\n                const regExp = '(?:([a-zA-Z_][a-zA-Z0-9_]{0,14}?(?!__c-))__)?([^-]+)-(?:([a-zA-Z_][a-zA-Z0-9_]{0,14}?_?(?!__c$))__)?(.+)\\n?';\n                const layoutFullName = change.n.match(regExp);\n                let layoutName = layoutFullName[4].replace(/_{2}(?!c)/g, (match) => {return match.replace(/_/gi,'%5F') });\n                layoutName = layoutName.replace(/\\./,'%2E');\n                change.n = `${layoutFullName[1] ? layoutFullName[1] + \"__\" : \"\"}${layoutFullName[2]}-${layoutFullName[3] ? layoutFullName[3] + \"__\" : \"\"}${layoutName}`;\n                break;\n        }\n\t}\n    writeFileSync('/app/encoded_changes.json', JSON.stringify(deploymentMetadata));\n}\n\nfunction readFromPath(filePath) {\n    return JSON.parse(readFileSync(filePath, 'utf-8'));\n}",
                    "copado__Type__c": "Standard",
                    "Id": "a0l7Q000000MDYyQAO",
                    "LastReferencedDate": "2022-09-16T10:59:41.000+0000",
                    "LastViewedDate": "2022-09-16T10:59:41.000+0000",
                    "Name": "Encode File Names"
                },
                {
                    "attributes": {
                        "type": "copado__Function__c",
                        "url": "/services/data/v56.0/sobjects/copado__Function__c/a0l7Q000000iAiOQAU"
                    },
                    "copado__API_Name__c": "sfdx_package_version_publish",
                    "copado__Description__c": "To publish the package version",
                    "copado__Image_Name__c": "copado-multicloud-dx:v3",
                    "copado__Options__c": "[ ]",
                    "copado__Parameters__c": "[ {\n  \"required\" : true,\n  \"name\" : \"versionDetails\",\n  \"defaultValue\" : \"{$Job.PrevStep.Result__r.Result_Data__c}\"\n}, {\n  \"required\" : true,\n  \"name\" : \"sessionId\",\n  \"defaultValue\" : \"{$Destination.Credential.SessionId}\"\n}, {\n  \"required\" : true,\n  \"name\" : \"endpoint\",\n  \"defaultValue\" : \"{$Destination.Credential.Endpoint}\"\n} ]",
                    "copado__Script__c": "#!/usr/bin/env node\n'use strict';\n\nconst { execSync } = require('child_process'),\n    { versionDetails, endpoint, sessionId, isTest } = process.env,\n    { subscriberId, apiVersion } = JSON.parse(versionDetails),\n    CHECK_LOG = 'Please check logs for more details',\n    TEMP_DIRECTORY = 'temp';\n\n// SCRIPT FUNCTIONS\n\nfunction execute() {\n    try {\n        endpoint && this.setInstanceURL(endpoint);\n        this.createSFDXProject(TEMP_DIRECTORY);\n        this.handlePromotionResponse(this.promotePackageVersion(subscriberId, sessionId, apiVersion, TEMP_DIRECTORY));\n\n        execSync(`\n            copado -p 'Package \"${subscriberId}\" promoted successfully'\n            copado -p 'Updating Results' -r ${subscriberId}`);\n    } catch (err) {\n        //Error status = 3, is when we have Custom Error Message, where error is already populated on result and hence we do not need to call it again.\n        if (err?.status === 3) {\n            process.exit(1);\n        }\n        execSync(this.showError(err?.toString()));\n    }\n}\n\nfunction setInstanceURL(endpoint) {\n    const url = endpoint.substring(0, endpoint.indexOf('/', endpoint.indexOf('/') + 2));\n    execSync(`\n        copado -p 'Setting instance url'\n        sfdx force:config:set instanceUrl=\"${url}\" --global || (${this.showError(`Error setting instance URL, ${CHECK_LOG}`)})\n    `);\n}\n\nfunction showError(error) {\n    const refinedErrorMsg = this.maskSensitiveInformation(error);\n    return `copado -p 'Error' -e ${JSON.stringify(refinedErrorMsg).replace(/\\\\n/g, '\\n')} ${isTest ? '' : ' && exit 3'}`;\n}\n\nfunction createSFDXProject(directory) {\n    execSync(`\n        copado -p 'Creating Temp Project'\n        sfdx force:project:create -n ${directory} || (${this.showError(`Error creating SFDX project, ${CHECK_LOG}`)})\n    `);\n}\n\nfunction promotePackageVersion(subscriberId, sessionId, apiVersion, directory) {\n    const promoteCmd = `sfdx force:package:version:promote -p ${subscriberId} -v ${sessionId} ${\n        apiVersion ? `--apiversion ${apiVersion}` : ''\n    } -n --json || true`;\n    this.logger(`Package Version Promotion Command ==> ${promoteCmd}`);\n\n    return JSON.parse(\n        execSync(`\n        copado -p 'Promoting package ${subscriberId}'\n        cd ${directory} || exit 1\n        ${promoteCmd}\n    `).toString()\n    );\n}\n\nfunction handlePromotionResponse(response) {\n    this.logger(`Package Version Promotion Response ==> ${JSON.stringify(response)}`);\n    if (response.status) {\n        throw `${response.message ? response.message : ''} ${CHECK_LOG}`;\n    }\n}\n\nfunction logger(text) {\n    console.log(text);\n}\n\nfunction maskSensitiveInformation(data) {\n    const sensitiveInfo = ['--targetdevhubusername', '-u', '-v'],\n        maskingSequence = '*****';\n\n    const arrayOfData = data.split(' ');\n    sensitiveInfo.forEach((subString) => {\n        const keyIndex = arrayOfData.indexOf(subString);\n        if (keyIndex > -1) {\n            arrayOfData[keyIndex + 1] = maskingSequence;\n            data = arrayOfData.join(' ');\n        }\n    });\n    return data;\n}\n\nmodule.exports.execute = execute;\nmodule.exports.logger = logger;\nmodule.exports.handlePromotionResponse = handlePromotionResponse;\nmodule.exports.promotePackageVersion = promotePackageVersion;\nmodule.exports.createSFDXProject = createSFDXProject;\nmodule.exports.showError = showError;\nmodule.exports.setInstanceURL = setInstanceURL;\nmodule.exports.maskSensitiveInformation = maskSensitiveInformation;\n\n// EXECUTION\n\n!isTest && this.execute();",
                    "copado__Type__c": "Standard",
                    "copado__Version__c": "1.0",
                    "Id": "a0l7Q000000iAiOQAU",
                    "LastReferencedDate": "2023-01-19T12:10:29.000+0000",
                    "LastViewedDate": "2023-01-19T12:10:29.000+0000",
                    "Name": "Sfdx Package Version Publish"
                },
                {
                    "attributes": {
                        "type": "copado__Function__c",
                        "url": "/services/data/v56.0/sobjects/copado__Function__c/a0l7Q000000iAiPQAU"
                    },
                    "copado__API_Name__c": "SFDX_Package_Version_Update",
                    "copado__Description__c": "Updates package version",
                    "copado__Image_Name__c": "copado-multicloud-dx:v3",
                    "copado__Options__c": "[ ]",
                    "copado__Parameters__c": "[ {\n  \"required\" : true,\n  \"name\" : \"devhubSession\",\n  \"defaultValue\" : \"{$Context.Credential.SessionId}\"\n}, {\n  \"required\" : true,\n  \"name\" : \"devhubEndpoint\",\n  \"defaultValue\" : \"{$Context.Credential.Endpoint}\"\n}, {\n  \"required\" : false,\n  \"name\" : \"packageVersion\",\n  \"defaultValue\" : \"{$Context.JobExecution__r.DataJson.packageVersion}\"\n}, {\n  \"name\" : \"installationKey\",\n  \"defaultValue\" : \"{$Context.JobExecution__r.DataJson.installationKey}\"\n}, {\n  \"name\" : \"apiVersion\",\n  \"defaultValue\" : \"{$Context.JobExecution__r.DataJson.apiVersion}\"\n} ]",
                    "copado__Script__c": "#!/usr/bin/env node\n'use strict';\nconst { execSync } = require('child_process'),\n    { devhubEndpoint, devhubSession, installationKey, apiVersion, isTest } = process.env,\n    baseUrl = devhubEndpoint.substring(0, devhubEndpoint.indexOf('/', devhubEndpoint.indexOf('/') + 2)),\n    packageVersion = JSON.parse(process.env.packageVersion),\n    CHECK_LOG = 'Please check the logs for details',\n    TEMP_DIRECTORY = 'temp';\n\n//SCRIPT FUNCTIONS\n\nfunction execute() {\n    try {\n        this.createSFDXProject(TEMP_DIRECTORY);\n        this.setInstanceURL(baseUrl);\n\n        const flags = this.buildParameters({\n            targetdevhubusername: devhubSession,\n            package: packageVersion.copado__Subscriber_Version_Id__c,\n            versionname: packageVersion.copado__Version_Name__c,\n            versiondescription: packageVersion.copado__Version_Description__c,\n            branch: packageVersion.copado__Branch__c,\n            tag: packageVersion.copado__Tag__c,\n            installationkey: installationKey,\n            apiversion: apiVersion\n        });\n\n        this.handleVersionPromotionResponse(this.updatePackageVersion(flags));\n        this.updateResult(packageVersion, installationKey);\n    } catch (error) {\n        //Error status = 3, is when we have Custom Error Message, where error is already populated on result and hence we do not need to call it again.\n        if (error?.status === 3) {\n            process.exit(1);\n        }\n        execSync(this.showError(error.toString()));\n    }\n}\n\nfunction updateResult(packageVersion, installationKey) {\n    const updateResultCmd = `copado -p 'Updating result' -r ${JSON.stringify(\n        JSON.stringify({\n            packageVersion,\n            installationKey: installationKey.replace(/\\\\\"/g, '\"')\n        })\n    )}`;\n    //escaping special characters here, so it can be used in payload\n    execSync(this.escapeSpecialCharacters(updateResultCmd));\n}\n\nfunction buildParameters(flags) {\n    return Object.entries(flags).reduce((parameters, [key, value]) => {\n        return parameters + (value ? ` --${key} \"${value}\"` : '');\n    }, '');\n}\n\nfunction setInstanceURL(url) {\n    execSync(`\n        sfdx -v\n        copado -p 'Setting instance url'\n        sfdx force:config:set instanceUrl=${url} || (${this.showError(`Error setting instance URL, ${CHECK_LOG}`)})\n    `);\n}\n\nfunction createSFDXProject(directory) {\n    execSync(`\n        copado -p 'Creating Temp Project'\n        sfdx force:project:create -n ${directory} || (${this.showError(`Error creating SFDX project, ${CHECK_LOG}`)})\n    `);\n\n    process.chdir(directory);\n}\n\nfunction showError(error) {\n    const refinedErrorMsg = this.maskSensitiveInformation(error);\n    return `copado -p 'Error' -e ${this.escapeSpecialCharacters(JSON.stringify(refinedErrorMsg)).replace(/\\\\n/g, '\\n')}  ${\n        isTest ? '' : '&&  exit 3'\n    }`;\n}\n\nfunction updatePackageVersion(parameters) {\n    const updateCmd = `\n        copado -p 'Updating package version'\n        sfdx force:package:version:update ${parameters} --json || true\n    `;\n    this.logger(`Package Version Update Command ==> sfdx force:package:version:update ${parameters} --json`);\n    //escaping special characters here, so it can be used in payload\n    return JSON.parse(execSync(this.escapeSpecialCharacters(updateCmd)).toString());\n}\n\nfunction handleVersionPromotionResponse(response) {\n    this.logger(`Package Version Update Response ==> ${JSON.stringify(response)}`);\n    if (response.status) {\n        execSync(this.showError(`Package Version Update failed. ${response.message}, ${CHECK_LOG}`));\n    }\n}\n\nfunction escapeSpecialCharacters(text) {\n    return text.replace(/`/g, '\\\\`').replace(/\\$/g, '\\\\$');\n}\n\nfunction logger(text) {\n    console.log(text);\n}\n\nfunction maskSensitiveInformation(data) {\n    const sensitiveInfo = ['--targetdevhubusername', '-u', '-v'],\n        maskingSequence = '*****';\n    const arrayOfData = data.split(' ');\n    sensitiveInfo.forEach((subString) => {\n        const keyIndex = arrayOfData.indexOf(subString);\n        if (keyIndex > -1) {\n            arrayOfData[keyIndex + 1] = maskingSequence;\n            data = arrayOfData.join(' ');\n        }\n    });\n    return data;\n}\n\nmodule.exports.execute = execute;\nmodule.exports.updateResult = updateResult;\nmodule.exports.buildParameters = buildParameters;\nmodule.exports.setInstanceURL = setInstanceURL;\nmodule.exports.createSFDXProject = createSFDXProject;\nmodule.exports.showError = showError;\nmodule.exports.updatePackageVersion = updatePackageVersion;\nmodule.exports.handleVersionPromotionResponse = handleVersionPromotionResponse;\nmodule.exports.escapeSpecialCharacters = escapeSpecialCharacters;\nmodule.exports.logger = logger;\nmodule.exports.maskSensitiveInformation = maskSensitiveInformation;\n\n// EXECUTION\n\n!isTest && this.execute();",
                    "copado__Type__c": "Standard",
                    "copado__Version__c": "1",
                    "Id": "a0l7Q000000iAiPQAU",
                    "LastReferencedDate": "2022-10-06T09:24:14.000+0000",
                    "LastViewedDate": "2022-10-06T09:24:14.000+0000",
                    "Name": "SFDX Package Version Update"
                },
                {
                    "attributes": {
                        "type": "copado__Function__c",
                        "url": "/services/data/v56.0/sobjects/copado__Function__c/a0l7Q000000iAiQQAU"
                    },
                    "copado__API_Name__c": "SFDX_Package_Version_Create",
                    "copado__Description__c": "Create a package version record",
                    "copado__Image_Name__c": "copado-multicloud-dx:v3",
                    "copado__Options__c": "[ ]",
                    "copado__Parameters__c": "[ {\n  \"required\" : true,\n  \"name\" : \"endPoint\",\n  \"defaultValue\" : \"{$Destination.Credential.Endpoint}\"\n}, {\n  \"required\" : true,\n  \"name\" : \"session\",\n  \"defaultValue\" : \"{$Destination.Credential.SessionId}\"\n}, {\n  \"required\" : false,\n  \"name\" : \"packageId\",\n  \"defaultValue\" : \"\"\n}, {\n  \"name\" : \"versionName\",\n  \"defaultValue\" : \"\"\n}, {\n  \"name\" : \"versionNumber\",\n  \"defaultValue\" : \"\"\n}, {\n  \"name\" : \"description\",\n  \"defaultValue\" : \"\"\n}, {\n  \"required\" : false,\n  \"name\" : \"jsonInformation\",\n  \"defaultValue\" : \"\"\n}, {\n  \"required\" : true,\n  \"name\" : \"git_json\",\n  \"defaultValue\" : \"{$Context.Repository.Credential}\"\n}, {\n  \"name\" : \"gitName\",\n  \"defaultValue\" : \"{$User.Name}\"\n}, {\n  \"name\" : \"gitEmail\",\n  \"defaultValue\" : \"{$User.Email}\"\n} ]",
                    "copado__Script__c": "#!/usr/bin/env node\n\nconst { mkdirSync, readFileSync } = require('fs'),\n    { execSync } = require('child_process'),\n    { packageId, versionName, versionNumber, description, endPoint, session, gitEmail, gitName } = process.env,\n    params = JSON.parse(\n        process?.env['jsonInformation']\n            .replace(/(\\\\r\\\\n|\\\\r|\\\\n)/g, '')\n            .replace(/\\\\\"/g, '\"')\n            .replace(/\\\\\\\\/g, '\\\\')\n    ),\n    checkLog = 'Please check the logs for details',\n    baseUrl = endPoint?.substring(0, endPoint?.indexOf('/', endPoint?.indexOf('/') + 2));\nparams.tag = params.tag ? stripTag(params.tag) : '';\nconst {\n    branch,\n    tag,\n    loglevel,\n    apiversion,\n    path,\n    definitionfile,\n    installationkey,\n    installationkeybypass,\n    codecoverage,\n    releasenotesurl,\n    postinstallurl,\n    postinstallscript,\n    uninstallscript,\n    skipvalidation\n} = params;\n\n// EXECUTION\n\nexecute();\n\nfunction execute() {\n    try {\n        mkdirSync('sfProject');\n        process.chdir('sfProject');\n\n        cloneRepo();\n        setInstanceURL();\n        configureGit();\n        updatePkgVersionCreation(pkgVersionCreation());\n    } catch (err) {\n        //Error status = 3, is when we have Custom Error Message, where error is already populated on result and hence we do not need to call it again.\n        if (err?.status === 3) {\n            process.exit(1);\n        }\n        execSync(`${getErrorCmd(err.toString())}`);\n    }\n}\n\n// SCRIPT FUNCTIONS\nfunction updatePkgVersionCreation(response) {\n    if (!response.status) {\n        commit();\n        updateTagBranchDetails(response.result.SubscriberPackageVersionId);\n        setProgressStatus({\n            progressStatus: 'Package version created successfully',\n            resultData: JSON.stringify(getLatestVersion(response?.result?.SubscriberPackageVersionId))\n        });\n    } else if (response.status) {\n        setProgressStatus({ progressStatus: 'Package Version creation failed', errorMessage: `Could not create package. ${response.message}` });\n    }\n}\n\nfunction getLatestVersion(pkgVersionId) {\n    const versionList = execSync(`sfdx force:package:version:list -v ${session} -p ${packageId} --verbose --json`).toString();\n    return JSON.parse(versionList)?.result?.find((version) => version.SubscriberPackageVersionId === pkgVersionId);\n}\n\nfunction pkgVersionCreation() {\n    const parameters = buildParameters({\n        loglevel,\n        targetdevhubusername: session,\n        apiversion,\n        package: packageId,\n        path,\n        branch,\n        definitionfile,\n        tag,\n        installationkey,\n        installationkeybypass,\n        wait: 1000,\n        versionname: versionName,\n        versionnumber: versionNumber,\n        versiondescription: description,\n        codecoverage,\n        releasenotesurl,\n        postinstallurl,\n        postinstallscript,\n        uninstallscript,\n        skipvalidation\n    });\n    logger(`Package Version Create Command ==> sfdx force:package:version:create ${parameters} --json`);\n    const versionCreateCmd = `\n        copado -p 'Creating package version'\n        sfdx force:package:version:create ${parameters} --json || true\n    `;\n\n    const response = execSync(escapeSpecialCharacters(versionCreateCmd)).toString();\n    logger(`Package Version Create Response ==> ${response}`);\n    return JSON.parse(response);\n}\n\nfunction createTag(tag) {\n    execSync(\n        `\n        git tag '${tag}' HEAD ||\n            (${getErrorCmd(`Error creating tag '${tag}' in git, ${checkLog}`)})\n    `,\n        { stdio: 'inherit' }\n    );\n}\n\nfunction deleteTag(tag) {\n    let tagForDeletion = escapeCharactersForTagDeletion(tag);\n    execSync(\n        `git push --delete origin refs/tags/${tagForDeletion} || (${getErrorCmd(\n            `Error deleting existing tag ${tagForDeletion} in git, ${checkLog}`\n        )})`,\n        { stdio: 'inherit' }\n    );\n}\n\nfunction escapeCharactersForTagDeletion(tag) {\n    return tag\n        .replace(/`/g, '\\\\`')\n        .replace(/\\$/g, '\\\\$')\n        .replace(/\\\"/g, '\\\\\"')\n        .replace(/\\'/g, \"\\\\'\")\n        .replace(/\\(/g, '\\\\(')\n        .replace(/\\)/g, '\\\\)')\n        .replace(/\\|/g, '\\\\|')\n        .replace(/</g, '\\\\<')\n        .replace(/>/g, '\\\\>')\n        .replace(/#/g, '\\\\#')\n        .replace(/&/g, '\\\\&')\n        .replace(/\\\\\"/g, '\"');\n}\n\nfunction commit() {\n    execSync(\n        `\n        git add 'sfdx-project.json' || exit 1\n        git commit -m 'Committing sfdx-project.json' || exit 1\n    `,\n        { stdio: 'inherit' }\n    );\n}\n\nfunction pushTagAndBranchChanges(branch, tag) {\n    if (branch) {\n        execSync(`git push origin ${branch} || (${getErrorCmd(`Error pushing changes in git, ${checkLog}`)})`, { stdio: 'inherit' });\n    }\n    if (tag) {\n        execSync(`git push origin '${tag}' || (${getErrorCmd(`Error pushing changes in git, ${checkLog}`)})`, { stdio: 'inherit' });\n    }\n}\n\nfunction cloneRepo() {\n    execSync(\n        `\n    copado -p 'Cloning git repository'\n    copado-git-get ${branch} || (${getErrorCmd(`Error check out branch, ${checkLog}`)})\n  `,\n        { stdio: 'inherit' }\n    );\n}\n\nfunction setInstanceURL() {\n    execSync(\n        `\n    copado -p 'Setting instance url'\n    sfdx force:config:set instanceUrl=${baseUrl} --global || (${getErrorCmd(`Error setting instance URL, ${checkLog}`)})\n  `,\n        { stdio: 'inherit' }\n    );\n}\n\nfunction setProgressStatus({ progressStatus, errorMessage, resultData }) {\n    let escapedData = resultData ? JSON.stringify(resultData).replace(/`/g, '\\\\`').replace(/\\$/g, '\\\\$') : '';\n    const resultUpdateCmd = `copado -p '${progressStatus}' ${errorMessage ? `-e '${errorMessage}'` : ''} ${resultData ? `-r ${escapedData}` : ''}`;\n\n    execSync(resultUpdateCmd);\n    if (errorMessage) throw errorMessage;\n}\n\nfunction getErrorCmd(error) {\n    let refinedErrorMsg = maskSensitiveInformation(error);\n    return `copado -p 'Error' -e ${escapeSpecialCharacters(JSON.stringify(refinedErrorMsg)).replace(/\\\\n/g, '\\n').replace(/\\\\t/g, '\\t')} && exit 3`;\n}\n\nfunction readProjectJson() {\n    return JSON.parse(readFileSync('sfdx-project.json', 'utf-8'));\n}\n\nfunction getVersionAlias(object, value) {\n    return Object.keys(object).find((key) => object[key] === value);\n}\n\nfunction updateTagBranchDetails(subscriberVersionId) {\n    const gitTag = tag ? tag : stripTag(getVersionAlias(readProjectJson().packageAliases, subscriberVersionId));\n    let isTagExist = false;\n\n    if (tag) {\n        const remoteTags = execSync(`git ls-remote --tags --refs origin`).toString();\n        isTagExist = remoteTags\n            .split('\\n')\n            .map((step) => step.substring(step.indexOf('refs/tags/') + 10, step.length))\n            .includes(gitTag.replace(/\\\\\"/g, '\"'));\n    }\n\n    if (isTagExist) {\n        deleteTag(gitTag);\n    }\n\n    const escapedGitTag = escapeCharactersForTagCreation(gitTag);\n    createTag(escapedGitTag);\n\n    if (!tag) {\n        const response = updatePackageVersionTag(session, escapedGitTag, subscriberVersionId);\n        if (response.status) {\n            setProgressStatus({ progressStatus: 'Package Version tag update failed', errorMessage: response.message });\n        } else {\n            setProgressStatus({ progressStatus: `Package Version tag updated to ${escapedGitTag}` });\n        }\n    }\n\n    pushTagAndBranchChanges(branch, escapedGitTag);\n}\n\nfunction updatePackageVersionTag(devhubSession, tag, subscriberVersionId) {\n    const parameters = buildParameters({\n        targetdevhubusername: devhubSession,\n        package: subscriberVersionId,\n        tag: tag\n    });\n    const updateCmd = `\n        copado -p 'Updating package version'\n        sfdx force:package:version:update ${parameters} --json || true\n    `;\n    const response = execSync(updateCmd).toString();\n    logger(`Package Version Update Response ==> ${response}`);\n    return JSON.parse(response);\n}\n\nfunction buildParameters(flags) {\n    return Object.entries(flags).reduce((parameters, [key, value]) => {\n        return parameters + (typeof value == 'boolean' ? (value ? ` --${key}` : '') : value ? ` --${key} \"${value}\"` : '');\n    }, '');\n}\n\nfunction escapeCharactersForTagCreation(text) {\n    return text.replace(/\\\\\"/g, '\"').replace(/'/g, \"'\\\\''\").replace(/[|]/g, \"'\\\\|'\");\n}\n\nfunction escapeSpecialCharacters(text) {\n    let result = text.replace(/`/g, '\\\\`').replace(/\\$/g, '\\\\$');\n\n    return result;\n}\n\nfunction stripTag(tag) {\n    //removing ascii characters below 20hex, mentioned sequences, and a few characters such as (?*[~^\\*:)\n    return tag\n        .replace(/[\\u0000-\\u0020]/g, '')\n        .replace(/[~^:?*[\\\\]/g, '')\n        .replace(/(\\/\\/)/g, '')\n        .replace(/(\\.\\.)/g, '')\n        .replace(/(@{)/g, '')\n        .replace(/(\\/\\.)/g, '')\n        .replace(/^[\\/]/g, '')\n        .replace(/(\\.lock)$/g, '')\n        .replace(/[\\/\\.]$/g, '')\n        .replace(/(\\.\\/$)/g, '')\n        .replace(/\\\"/g, '\\\\\"');\n}\n\nfunction logger(text) {\n    console.log(text);\n}\n\nfunction configureGit() {\n    execSync(\n        `\n        git config --local user.email \"${gitEmail}\" || exit 1\n        git config --local user.name \"${gitName}\" || exit 1`,\n        { stdio: 'inherit' }\n    );\n}\n\nfunction maskSensitiveInformation(data) {\n    const sensitiveInfo = ['--targetdevhubusername', '-u', '-v'],\n        maskingSequence = '*****';\n\n    const arrayOfData = data.split(' ');\n    sensitiveInfo.forEach((subString) => {\n        const keyIndex = arrayOfData.indexOf(subString);\n        if (keyIndex > -1) {\n            arrayOfData[keyIndex + 1] = maskingSequence;\n            data = arrayOfData.join(' ');\n        }\n    });\n    return data;\n}",
                    "copado__Type__c": "Standard",
                    "copado__Version__c": "1",
                    "Id": "a0l7Q000000iAiQQAU",
                    "LastReferencedDate": "2022-10-17T09:29:23.000+0000",
                    "LastViewedDate": "2022-10-17T09:29:23.000+0000",
                    "Name": "SFDX Package Version Create"
                },
                {
                    "attributes": {
                        "type": "copado__Function__c",
                        "url": "/services/data/v56.0/sobjects/copado__Function__c/a0l7Q000000iAiRQAU"
                    },
                    "copado__API_Name__c": "SFDX_Get_Package_Version_Dependencies",
                    "copado__Image_Name__c": "copado-multicloud-dx:v3",
                    "copado__Options__c": "[ ]",
                    "copado__Parameters__c": "[ {\n  \"required\" : true,\n  \"name\" : \"endpoint\",\n  \"defaultValue\" : \"{$Source.Credential.Endpoint}\"\n}, {\n  \"required\" : true,\n  \"name\" : \"session\",\n  \"defaultValue\" : \"{$Source.Credential.SessionId}\"\n}, {\n  \"required\" : true,\n  \"name\" : \"subscriberVersionId\",\n  \"defaultValue\" : \"{$Context.JobExecution__r.DataJson.subscriberId}\"\n}, {\n  \"required\" : false,\n  \"name\" : \"installationKey\",\n  \"defaultValue\" : \"{$Context.JobExecution__r.DataJson.installationKey}\"\n} ]",
                    "copado__Script__c": "#!/usr/bin/env node\nconst { execSync } = require('child_process'),\n    { endpoint, session, subscriberVersionId, installationKey } = process.env,\n    baseUrl = endpoint.substring(0, endpoint.indexOf('/', endpoint.indexOf('/') + 2)),\n    checkLog = 'Please check the logs for details';\n\n// EXECUTON\n\nexecute();\n\nfunction execute() {\n    try {\n        setInstanceURL();\n        const dependencies = getVersionDependencies();\n        handleDependenciesResponse(dependencies);\n    } catch (err) {\n        //Error status = 3, is when we have Custom Error Message, where error is already populated on result and hence we do not need to call it again.\n        if (err?.status === 3) {\n            process.exit(1);\n        }\n        execSync(`${getErrorCmd(err.toString())}`);\n    }\n}\n\n// SCRIPT FUNCTIONS\n\nfunction setInstanceURL() {\n    execSync(\n        `\n\t  copado -p 'Setting instance url'\n\t  sfdx force:config:set instanceUrl=${baseUrl} --global || (${getErrorCmd(`Error setting instance URL, ${checkLog}`)})\n\t`,\n        { stdio: 'inherit' }\n    );\n}\n\nfunction getVersionDependencies() {\n    const query = `SELECT MajorVersion, MinorVersion, PatchVersion, BuildNumber, SubscriberPackageId, Dependencies FROM SubscriberPackageVersion WHERE Id='${subscriberVersionId}' ${addFilter()}`;\n    logger(`SubscriberPackageVersion Query From Devhub  ==> ${query}`);\n\n    const result = execSync(`\n\t\t\tcopado -p 'Getting dependencies'\n\t\t\tsfdx force:data:soql:query -t -q \"${query}\" -u ${session} --json || true\n\t\t`).toString();\n    logger(`SubscriberPackageVersion Tooling API Response ==> ${JSON.stringify(result)}`);\n\n    return JSON.parse(result);\n}\n\nfunction getErrorCmd(error) {\n    const refinedErrorMsg = maskSensitiveInformation(error);\n    return `copado -p 'Error' -e ${JSON.stringify(refinedErrorMsg).replace(/\\\\n/g, '\\n').replace(/\\\\t/g, '\\t')} && exit 3`;\n}\n\nfunction addFilter() {\n    return installationKey ? `AND InstallationKey='${installationKey}'` : '';\n}\n\nfunction handleDependenciesResponse(response) {\n    let updateResult;\n    if (!response.status) {\n        const apiResponse = response?.result?.totalSize && response?.result?.records[0];\n        const result = getResult(apiResponse);\n\n        updateResult = `copado -p 'Updating dependencies' -r '${JSON.stringify(result)}'`;\n    } else {\n        updateResult = getErrorCmd(`${response.name}: ${response.message}`);\n    }\n    if (updateResult) {\n        execSync(updateResult, {\n            stdio: 'inherit'\n        });\n    }\n}\n\nfunction logger(text) {\n    console.log(text);\n}\n\nfunction mapDependencies(response) {\n    let dependencies = [];\n    if (response?.Dependencies?.ids?.length) {\n        dependencies = response.Dependencies.ids.map((dependency) => dependency.subscriberPackageVersionId);\n    }\n    return dependencies;\n}\n\nfunction getResult(apiResponse) {\n    return {\n        subscriberVersionId: subscriberVersionId,\n        dependencies: apiResponse && mapDependencies(apiResponse),\n        versionNumber:\n            apiResponse && `${apiResponse.MajorVersion}.${apiResponse.MinorVersion}.${apiResponse.PatchVersion}.${apiResponse.BuildNumber}`,\n        subscriberPackageId: apiResponse && apiResponse.SubscriberPackageId\n    };\n}\n\nfunction maskSensitiveInformation(data) {\n    const sensitiveInfo = ['--targetdevhubusername', '-u', '-v'],\n        maskingSequence = '*****';\n\n    const arrayOfData = data.split(' ');\n    sensitiveInfo.forEach((subString) => {\n        const keyIndex = arrayOfData.indexOf(subString);\n        if (keyIndex > -1) {\n            arrayOfData[keyIndex + 1] = maskingSequence;\n            data = arrayOfData.join(' ');\n        }\n    });\n    return data;\n}",
                    "copado__Type__c": "Standard",
                    "copado__Worker_Size__c": "S",
                    "Id": "a0l7Q000000iAiRQAU",
                    "LastReferencedDate": "2022-11-15T12:30:28.000+0000",
                    "LastViewedDate": "2022-11-15T12:30:28.000+0000",
                    "Name": "SFDX Get Package Version Dependencies"
                },
                {
                    "attributes": {
                        "type": "copado__Function__c",
                        "url": "/services/data/v55.0/sobjects/copado__Function__c/a0k09000000qQSoAAM"
                    },
                    "copado__API_Name__c": "sfdx_execute_apex",
                    "copado__Description__c": "Run sfdx force:apex:execute to execute Apex Job Steps.",
                    "copado__Image_Name__c": "copado-multicloud-dx:v3",
                    "copado__Options__c": "[ ]",
                    "copado__Parameters__c": "[ {\n  \"required\" : true,\n  \"name\" : \"destination_sessionid\",\n  \"defaultValue\" : \"{$Destination.Credential.SessionId}\"\n}, {\n  \"required\" : true,\n  \"name\" : \"destination_endpoint\",\n  \"defaultValue\" : \"{$Destination.Credential.Endpoint}\"\n}, {\n  \"required\" : false,\n  \"name\" : \"script\"\n}, {\n  \"required\" : true,\n  \"name\" : \"destination_env_var\",\n  \"defaultValue\" : \"{$Destination.apex.EnvironmentVariables}\"\n}, {\n  \"required\" : true,\n  \"name\" : \"isValidation\",\n  \"defaultValue\" : \"{$Context.JobExecution__r.DataJson.deploymentDryRun}\"\n} ]",
                    "copado__Script__c": "#!/usr/bin/env node\n/**\n * Performs execution of apex script using sfdx cli command.\n * @param destination_sessionid\n * @param destination_endpoint\n * @param script\n * @param destination_env_var\n * @param isValidation\n */\n\nconst fs = require(\"fs\"),\n  { execSync } = require(\"child_process\"),\n  { destination_sessionid, destination_endpoint, script, destination_env_var, isValidation } = process.env,\n  destination_base_url = getBaseUrl(destination_endpoint),\n  scriptName = \"script.apex\",\n  validationModeMessage = \"This step will not be executed for validate changes\";\n\n// EXECUTION\n\ntry {\n  validateExecutionMode();\n  setup();\n  executeApexScript();\n} catch (error) {\n  logError(error);\n}\n\n// FUNCTIONS\n\nfunction getBaseUrl(endpoint) {\n  return endpoint.substring(\n    0,\n    endpoint.indexOf(\"/\", endpoint.indexOf(\"/\") + 2)\n  );\n}\n\nfunction setup() {\n  const content = script.replace(\"\\\\n\", \" \");\n  fs.writeFileSync(scriptName, content);\n  const cmd = `\n      copado -p \"Replacing environment dependent value\"\n\t  varreplace '${destination_env_var}' '${scriptName}' --valuename=false\n      copado -p 'Connecting to destination environment'\n      sfdx force:config:set instanceUrl=${destination_base_url} --global\n  `;\n  execSync(cmd, { stdio: \"inherit\" });\n}\n\nfunction executeApexScript() {\n  const cmd = `\n        copado -p 'Executing apex script'\n        sfdx force:apex:execute -u ${destination_sessionid} -f '${scriptName}' --json\n  `;\n  const response = execSync(cmd, { maxBuffer: 50 * 1024 * 1024 });\n  validateResponse(response);\n}\n\nfunction validateResponse(response) {\n  if (!response) {\n    throw \"Apex script execution failed\";\n  }\n  const formattedResponse = JSON.parse(response.toString());\n  if (formattedResponse.status != 0) {\n    throw formattedResponse?.message;\n  } else if (!formattedResponse?.result?.compiled || !formattedResponse?.result?.success) {\n    throw `Error occured: \"${JSON.stringify(formattedResponse?.result)}\". Please check logs for more details.`;\n  } else {\n    execSync(`copado -p 'Apex script execution completed successfully'`);\n  }\n}\n\nfunction logError(error) {\n  execSync(`copado -p 'Error' -e \"${error.toString()}\" && exit 1`);\n}\n\nfunction validateExecutionMode() {\n  if(isValidation === 'true') {\n    execSync(`copado -p '${validationModeMessage}' --result-data '${validationModeMessage}'`);\n\tprocess.exit(0);\n  }\n}",
                    "copado__Timeout__c": 60,
                    "copado__Type__c": "Standard",
                    "copado__Version__c": "1",
                    "copado__Worker_Size__c": "M",
                    "Id": "a0k09000000qQSoAAM",
                    "LastReferencedDate": "2022-06-27T07:54:21.000+0000",
                    "LastViewedDate": "2022-06-27T07:54:21.000+0000",
                    "Name": "SFDX Execute Apex"
                },
                {
                    "attributes": {
                        "type": "copado__Function__c",
                        "url": "/services/data/v56.0/sobjects/copado__Function__c/a0l7Q000000iAiTQAU"
                    },
                    "copado__API_Name__c": "SFDXPackageCreate",
                    "copado__Image_Name__c": "copado-multicloud-dx:v3",
                    "copado__Options__c": "[ ]",
                    "copado__Parameters__c": "[ {\n  \"required\" : true,\n  \"name\" : \"devhubEndpoint\",\n  \"defaultValue\" : \"{$Destination.Credential.Endpoint}\"\n}, {\n  \"required\" : true,\n  \"name\" : \"devhubSession\",\n  \"defaultValue\" : \"{$Destination.Credential.SessionId}\"\n}, {\n  \"required\" : false,\n  \"name\" : \"packageName\",\n  \"defaultValue\" : \"\"\n}, {\n  \"name\" : \"path\",\n  \"defaultValue\" : \"\"\n}, {\n  \"name\" : \"jsonInformation\",\n  \"defaultValue\" : \"\"\n}, {\n  \"name\" : \"description\",\n  \"defaultValue\" : \"\"\n}, {\n  \"required\" : true,\n  \"name\" : \"git_json\",\n  \"defaultValue\" : \"{$Context.Repository.Credential}\"\n}, {\n  \"name\" : \"branch\",\n  \"defaultValue\" : \"\"\n}, {\n  \"name\" : \"gitName\",\n  \"defaultValue\" : \"{$User.Name}\"\n}, {\n  \"name\" : \"gitEmail\",\n  \"defaultValue\" : \"{$User.Email}\"\n} ]",
                    "copado__Script__c": "#!/usr/bin/env node\n'use strict';\nconst { mkdirSync, readFileSync } = require('fs'),\n    { execSync } = require('child_process'),\n    { gitEmail, gitName, devhubEndpoint, branch, devhubSession, packageName, path, description, isTest } = process.env,\n    { loglevel, apiversion, packagetype, nonamespace, orgdependent, errornotificationusername, namespaceprefix } = JSON.parse(\n        process.env['jsonInformation']?.replace(/\\\\/g, '')\n    ),\n    baseUrl = devhubEndpoint?.substring(0, devhubEndpoint?.indexOf('/', devhubEndpoint?.indexOf('/') + 2)),\n    DIR_NAME = 'sfProject',\n    CHECK_LOG = 'Please check the logs for details',\n    SFDX_PROJECT_JSON = 'sfdx-project.json';\n\n// SCRIPT FUNCTIONS\n\nfunction execute() {\n    try {\n        this.setupDirectory(DIR_NAME);\n        this.prepareAndCloneRepo(branch);\n        this.setInstanceUrl(baseUrl);\n        this.configureGit(gitEmail, gitName);\n        this.validateNamespace(namespaceprefix, nonamespace);\n        const flags = this.buildParameters({\n            loglevel,\n            targetdevhubusername: devhubSession,\n            apiversion,\n            name: packageName,\n            path,\n            packagetype,\n            nonamespace,\n            orgdependent,\n            description,\n            errornotificationusername\n        });\n        this.createPackage(flags);\n    } catch (err) {\n        //Error status = 3, is when we have Custom Error Message, where error is already populated on result and hence we do not need to call it again.\n        if (err?.status === 3) {\n            process.exit(1);\n        }\n        execSync(`${this.getErrorCmd(err.toString())}`);\n    }\n}\n\nfunction setupDirectory(dirName) {\n    mkdirSync(dirName);\n    process.chdir(dirName);\n}\n\nfunction buildParameters(flags) {\n    return Object.entries(flags).reduce((parameters, [key, value]) => {\n        return parameters + (typeof value == 'boolean' ? (value ? ` --${key}` : '') : value ? ` --${key} \"${value}\"` : '');\n    }, '');\n}\n\nfunction getPackagesList(sessionId) {\n    return JSON.parse(execSync(`sfdx force:package:list -v ${sessionId} --json || true`).toString());\n}\n\nfunction prepareAndCloneRepo(branchName) {\n    execSync(`\n        copado -p 'Cloning git repository'\n        copado-git-get '${branchName}' || (${this.getErrorCmd(`Could not checkout branch ${branchName}, ${CHECK_LOG}`)})\n    `);\n}\n\nfunction setInstanceUrl(baseUrl) {\n    execSync(`\n        copado -p 'Setting instance url'\n        sfdx force:config:set instanceUrl=${baseUrl} --global || (${this.getErrorCmd(`Failed setting an instance URL, ${CHECK_LOG}`)})\n    `);\n}\n\nfunction createPackage(pkgCreateParam) {\n    const createCmd = `sfdx force:package:create ${pkgCreateParam} --json`,\n        createCmdExec = `\n            copado -p 'Creating package'\n            ${createCmd} || true\n            copado -p 'Finishing'\n        `;\n    this.logger(`Package Create Command ==> ${createCmd}`);\n\n    //escaping special characters here, so it can be used in payload\n    const response = JSON.parse(execSync(this.escapeSpecialCharacters(createCmdExec)).toString());\n    this.logger(`Package Create Command Response ==> ${JSON.stringify(response)}`);\n\n    if (!response?.status && response?.result?.Id) {\n        this.commit();\n        const packageId = response.result.Id,\n            packagesDetails = this.getPackagesList(devhubSession);\n\n        if (packagesDetails?.status) {\n            this.setProgressStatus({\n                progressStatus: 'Error',\n                errorMessage: `Error fetching package version list from devhub, ${packagesDetails.message}`\n            });\n        } else {\n            const namespace = packagesDetails.result.find(pkg => pkg.Id === packageId)?.NamespacePrefix,\n                resultData = { packageId: packageId, namespace: namespace ? namespace : '' };\n            this.setProgressStatus({ progressStatus: 'Package created successfully', resultData: JSON.stringify(resultData) });\n        }\n    } else {\n        this.setProgressStatus({\n            progressStatus: 'Package creation failed',\n            errorMessage: `Could not create package, ${response.message}`\n        });\n    }\n}\n\nfunction commit() {\n    execSync(\n        `\n        git add '${SFDX_PROJECT_JSON}' || (${this.getErrorCmd(`Error adding git change, ${CHECK_LOG}`)})\n        git commit -m 'Committing sfdx-project.json' || (${this.getErrorCmd(`Error commiting git change, ${CHECK_LOG}`)})\n        git push origin ${branch} || (${this.getErrorCmd(`Error pushing changes in git, ${CHECK_LOG}`)})`,\n        { stdio: 'inherit' }\n    );\n}\n\nfunction setProgressStatus({ progressStatus, errorMessage, resultData }) {\n    execSync(`copado -p '${progressStatus}' ${errorMessage ? `-e '${errorMessage}'` : ''} ${resultData ? `-r '${resultData}'` : ''}`);\n    if (errorMessage) {\n        throw errorMessage;\n    }\n}\n\nfunction getErrorCmd(error) {\n    const refinedErrorMsg = this.maskSensitiveInformation(error);\n    return `copado -p 'Error' -e ${this.escapeSpecialCharacters(JSON.stringify(refinedErrorMsg).replace(/\\\\n/g, '\\n'))} ${isTest ? '' : '&& exit 3'}`;\n}\n\nfunction readProjectJson(fileName) {\n    try {\n        return JSON.parse(readFileSync(fileName, 'utf-8'));\n    } catch (err) {\n        throw `Issue while parsing sfdx-project.json file. \\n${err.toString()}`;\n    }\n}\n\nfunction escapeSpecialCharacters(text) {\n    return text?.replace(/`/g, '\\\\`')?.replace(/\\$/g, '\\\\$');\n}\n\nfunction logger(text) {\n    console.log(text);\n}\n\nfunction configureGit(gitEmail, gitName) {\n    execSync(\n        `\n        git config --local user.email \"${gitEmail}\" || (${this.getErrorCmd(`Issue configuring git email, ${CHECK_LOG}`)})\n        git config --local user.name \"${gitName}\" || (${this.getErrorCmd(`Issue configuring git name, ${CHECK_LOG}`)})`,\n        { stdio: 'inherit' }\n    );\n}\n\nfunction validateNamespace(namespaceprefix, nonamespace) {\n    if (namespaceprefix && !nonamespace && this.readProjectJson(SFDX_PROJECT_JSON)?.namespace !== namespaceprefix) {\n        this.setProgressStatus({\n            progressStatus: 'Error',\n            errorMessage: `Namespace in package record does not match with sfdx-project.json file in git repository.`\n        });\n    }\n}\n\nfunction maskSensitiveInformation(data) {\n    const sensitiveInfo = ['--targetdevhubusername', '-u', '-v'],\n        maskingSequence = '*****';\n\n    const arrayOfData = data.split(' ');\n    sensitiveInfo.forEach((subString) => {\n        const keyIndex = arrayOfData.indexOf(subString);\n        if (keyIndex > -1) {\n            arrayOfData[keyIndex + 1] = maskingSequence;\n            data = arrayOfData.join(' ');\n        }\n    });\n    return data;\n}\n\nmodule.exports.configureGit = configureGit;\nmodule.exports.logger = logger;\nmodule.exports.escapeSpecialCharacters = escapeSpecialCharacters;\nmodule.exports.readProjectJson = readProjectJson;\nmodule.exports.getErrorCmd = getErrorCmd;\nmodule.exports.setProgressStatus = setProgressStatus;\nmodule.exports.commit = commit;\nmodule.exports.createPackage = createPackage;\nmodule.exports.prepareAndCloneRepo = prepareAndCloneRepo;\nmodule.exports.setInstanceUrl = setInstanceUrl;\nmodule.exports.getPackagesList = getPackagesList;\nmodule.exports.buildParameters = buildParameters;\nmodule.exports.execute = execute;\nmodule.exports.setupDirectory = setupDirectory;\nmodule.exports.validateNamespace = validateNamespace;\nmodule.exports.maskSensitiveInformation = maskSensitiveInformation;\n\n// EXECUTION\n\n!isTest && this.execute();",
                    "copado__Type__c": "Standard",
                    "Id": "a0l7Q000000iAiTQAU",
                    "LastReferencedDate": "2023-01-17T08:03:11.000+0000",
                    "LastViewedDate": "2023-01-17T08:03:11.000+0000",
                    "Name": "SFDX Package Create"
                },
                {
                    "attributes": {
                        "type": "copado__Function__c",
                        "url": "/services/data/v54.0/sobjects/copado__Function__c/a0l7Q000000M5T0QAK"
                    },
                    "copado__API_Name__c": "SFDXRunApexTests",
                    "copado__Image_Name__c": "copado-multicloud-dx:v3",
                    "copado__Options__c": "[ ]",
                    "copado__Parameters__c": "[ {\n  \"name\" : \"source_session_id\",\n  \"defaultValue\" : \"{$Source.Credential.SessionId}\"\n}, {\n  \"name\" : \"source_endpoint\",\n  \"defaultValue\" : \"{$Source.Credential.Endpoint}\"\n}, {\n  \"name\" : \"namespace\",\n  \"defaultValue\" : \"\"\n}, {\n  \"name\" : \"source_path\",\n  \"defaultValue\" : \"force-app\"\n}, {\n  \"name\" : \"test_minutes_timeout\",\n  \"defaultValue\" : \"1440\"\n}, {\n  \"name\" : \"test_result_ids\",\n  \"defaultValue\" : \"{$Context.JobExecution__r.DataJson.resultIds}\"\n}, {\n  \"name\" : \"test_classes\",\n  \"defaultValue\" : \"{$Context.apex.cmcSf.GetTestClasses}\"\n}, {\n  \"name\" : \"consolidated_result_id\",\n  \"defaultValue\" : \"{$Context.JobExecution__r.DataJson.resultId}\"\n} ]",
                    "copado__Script__c": "prepareSfdxProject() {\n\tcopado -p \"Preparing sfdx project configuration\"\n\n\tsource_endpoint=($(node -p \"('$source_endpoint').substring(0, '$source_endpoint'.indexOf('.com') + 4)\"))\n    \n    mkdir -p .sfdx\n\tcat << __EOF__ > \".sfdx/sfdx-config.json\"\n\t{\n\t\t\"instanceUrl\": \"$source_endpoint\"\n\t}\n__EOF__\n\t\n    cat << __EOF__ > \"sfdx-project.json\"\n\t{\n\t\t\"namespace\": \"$namespace\",\n\t\t\"packageDirectories\": [\n\t\t\t{\n\t\t\t\t\"path\": \"$source_path\",\n                \"default\": true\n            }\n\t\t],\n        \"sfdcLoginUrl\": \"\"\n\t}\n__EOF__\n}\n\nrunApexTests() {\n\techo \"test classes: ${test_classes}\"\n    copado -p \"Running Apex Tests in the source environment\"\n    sfdx force:apex:test:run -u ${source_session_id} -t ${test_classes} -r json --detailedcoverage --codecoverage --verbose --wait ${test_minutes_timeout} > /tmp/apex-tests-output.json || true\n    jq 'del(.result.summary.username)' /tmp/apex-tests-output.json > tmp.$$.json && mv tmp.$$.json /tmp/apex-tests-output.json\n}\n\nattachResultFile() {\n    # To function result\n\tcopado -u /tmp/apex-tests-output.json --name \"apex-tests-output.json\"\n\n\t# To test independent results, if existing\n\tif [ -n \"$test_result_ids\" ];\n    then\n      test_result_ids=$(echo $test_result_ids | sed -e \"s/\\[//g\" | sed -e \"s/\\]//g\" | sed -e \"s/ //g\" | xargs)\n      IFS=','\n      for test_result_id in ${test_result_ids};\n      do\n          copado -u /tmp/apex-tests-output.json --name \"apex-tests-output.json\" --parentid $test_result_id\n      done\n    fi\n    \n    # To consolidated result, if existing\n\tif [ -n \"$consolidated_result_id\" ];\n    then\n\t    copado -u /tmp/apex-tests-output.json --name \"apex-tests-output.json\" --parentid $consolidated_result_id\n    fi\n}\n\nprepareSfdxProject\nrunApexTests\nattachResultFile",
                    "copado__Timeout__c": 1440,
                    "copado__Type__c": "Standard",
                    "copado__Version__c": "1",
                    "copado__Worker_Size__c": "S",
                    "Id": "a0l7Q000000M5T0QAK",
                    "LastReferencedDate": "2022-04-21T16:43:31.000+0000",
                    "LastViewedDate": "2022-04-21T16:43:31.000+0000",
                    "Name": "SFDX Run Apex Tests"
                },
                {
                    "attributes": {
                        "type": "copado__Function__c",
                        "url": "/services/data/v56.0/sobjects/copado__Function__c/a0l7Q000000iFzHQAU"
                    },
                    "copado__API_Name__c": "SFDX_Package_Version_Git_Config",
                    "copado__Description__c": "SFDX Package Version Git Config",
                    "copado__Image_Name__c": "copado-multicloud-dx:v3",
                    "copado__Options__c": "[ ]",
                    "copado__Parameters__c": "[ {\n  \"required\" : true,\n  \"name\" : \"packageVersion\",\n  \"defaultValue\" : \"{$Context.JobExecution__r.DataJson.packageVersion}\"\n}, {\n  \"required\" : true,\n  \"name\" : \"git_json\",\n  \"defaultValue\" : \"{$Context.Repository.Credential}\"\n}, {\n  \"name\" : \"dxNamespace\",\n  \"defaultValue\" : \"{$Context.apex.cmcSf.GetDxNamespace}\"\n} ]",
                    "copado__Script__c": "#!/usr/bin/env node\n'use strict';\n\n// IMPORTS\nconst fs = require('fs'),\n    { execSync } = require('child_process'),\n    process = require('process'),\n    { packageVersion, isTest, dxNamespace } = process.env,\n    versionDetail = JSON.parse(packageVersion);\n\n// CONSTANTS\n\nconst STDIO = {\n        INHERIT: 'inherit'\n    },\n    CHECK_LOG = 'Please check the logs for details',\n    PROJECT_DIRECTORY = 'sfProject',\n    PROJECT_JSON = 'sfdx-project.json';\n\n// SCRIPT FUNCTIONS\n\nfunction cloneRepo(branchName) {\n    if (!branchName) {\n        throw `Could not find branch name.`;\n    }\n\n    execSync(\n        `\n\t\tcopado -p 'Cloning git repository'\n\t\tcopado-git-get ${branchName} --depth 1 || (${this.getErrorCmd(`Error check out branch ${branchName}, ${CHECK_LOG}`)})`,\n        { stdio: STDIO.INHERIT }\n    );\n}\n\nfunction readProjectJson(file) {\n    try {\n        return JSON.parse(fs.readFileSync(file, 'utf-8'));\n    } catch (error) {\n        throw `Error parsing ${file}. ${error?.toString()}`;\n    }\n}\n\nfunction escapeSpecialCharacters(text) {\n    return text.replace(/`/g, '\\\\`').replace(/\\$/g, '\\\\$');\n}\n\nfunction getErrorCmd(error) {\n    return `copado -p 'Error' -e ${this.escapeSpecialCharacters(JSON.stringify(error))} ${isTest ? '' : '&& exit 3'}`;\n}\n\nfunction getDetailsFromProjectJson(projectJson, version, dxNamespace) {\n    const packageId = version?.copado__Artifact__r?.copado__Package_Id__c,\n        packageAliases = projectJson?.packageAliases,\n        recordNamespace = version?.copado__Artifact__r?.copado__Package_Namespace__c,\n        projectJsonNamespace = projectJson?.namespace,\n        pkgName = packageAliases ? Object.keys(packageAliases)?.find(pckgId => packageAliases[pckgId] === packageId) : undefined;\n\n    this.checkAttributesAndHandleErrors({ packageAliases, packageId, pkgName, recordNamespace, projectJsonNamespace });\n\n    const {\n        versionNumber,\n        versionDescription,\n        versionName,\n        postInstallUrl,\n        ancestorVersion,\n        ancestorId,\n        postInstallScript,\n        releaseNotesUrl,\n        uninstallScript,\n        definitionFile\n    } = this.getPackageDirectory(projectJson, pkgName);\n\n    return JSON.stringify({\n        packageVersion: {\n            Id: version.Id,\n            copado__Version_number__c: versionNumber,\n            copado__Version_Description__c: versionDescription,\n            copado__Version_Name__c: versionName,\n            [`${dxNamespace}Post_Install_URL__c`]: postInstallUrl,\n            [`${dxNamespace}Post_Install_Script__c`]: postInstallScript,\n            [`${dxNamespace}Release_Notes_URL__c`]: releaseNotesUrl,\n            [`${dxNamespace}Uninstall_Script__c`]: uninstallScript,\n            copado__DefinitionFile__c: definitionFile,\n            [`${dxNamespace}Ancestor_Version__c`]: ancestorVersion,\n            [`${dxNamespace}Ancestor_Id__c`]: ancestorId ? (packageAliases[ancestorId] ? packageAliases[ancestorId] : ancestorId) : undefined\n        }\n    });\n}\n\nfunction checkAttributesAndHandleErrors({ packageAliases, packageId, pkgName, recordNamespace, projectJsonNamespace }) {\n    if (!packageAliases) {\n        throw `Missing attribute packageAliases from project JSON file`;\n    }\n\n    if (!packageId || !pkgName) {\n        throw `Missing associated package either in Salesforce record or project JSON file.`;\n    }\n\n    if (recordNamespace && projectJsonNamespace && recordNamespace != projectJsonNamespace) {\n        throw `Mismatch of namespace in Package record and repository.`;\n    }\n}\n\nfunction setupDirectory(directory) {\n    fs.mkdirSync(directory);\n    process.chdir(directory);\n}\n\nfunction execute() {\n    try {\n        this.setupDirectory(PROJECT_DIRECTORY);\n        this.cloneRepo(versionDetail.copado__Branch__c);\n        execSync(\n            `\n            copado -p 'Fetching details from repository'`,\n            { stdio: STDIO.INHERIT }\n        );\n        const projectJson = this.readProjectJson(PROJECT_JSON);\n        const versionDetails = this.getDetailsFromProjectJson(projectJson, versionDetail, dxNamespace);\n        const result = this.escapeSpecialCharacters(JSON.stringify(versionDetails));\n        execSync(`copado -p 'Fetch Successful' -r ${result}`, { stdio: STDIO.INHERIT });\n    } catch (err) {\n        //Error status = 3, is when we have Custom Error Message, where error is already populated on result and hence we do not need to call it again.\n        if (err?.status === 3) {\n            process.exit(1);\n        }\n        execSync(`${this.getErrorCmd(err?.toString())}`);\n    }\n}\n\nfunction getPackageDirectory(projectJson, pkgName) {\n    const pkgDirectory = projectJson?.packageDirectories?.find(dir => dir.package === pkgName);\n    if (!pkgDirectory) {\n        throw `Could not find directory for package '${pkgName}' in packageDirectories attribute in project JSON file.`;\n    }\n    return pkgDirectory;\n}\n\nmodule.exports.cloneRepo = cloneRepo;\nmodule.exports.escapeSpecialCharacters = escapeSpecialCharacters;\nmodule.exports.readProjectJson = readProjectJson;\nmodule.exports.getErrorCmd = getErrorCmd;\nmodule.exports.getDetailsFromProjectJson = getDetailsFromProjectJson;\nmodule.exports.checkAttributesAndHandleErrors = checkAttributesAndHandleErrors;\nmodule.exports.execute = execute;\nmodule.exports.setupDirectory = setupDirectory;\nmodule.exports.getPackageDirectory = getPackageDirectory;\n\n// EXECUTION\n\n!isTest && this.execute();",
                    "copado__Timeout__c": 120,
                    "copado__Type__c": "Standard",
                    "Id": "a0l7Q000000iFzHQAU",
                    "LastReferencedDate": "2023-01-30T10:18:48.000+0000",
                    "LastViewedDate": "2023-01-30T10:18:48.000+0000",
                    "Name": "SFDX Package Version Git Config"
                },
                {
                    "attributes": {
                        "type": "copado__Function__c",
                        "url": "/services/data/v55.0/sobjects/copado__Function__c/a0k09000000rbjMAAQ"
                    },
                    "copado__API_Name__c": "SFDX_Deploy_Custom_Setting",
                    "copado__Description__c": "This function is used to create custom setting records",
                    "copado__Image_Name__c": "copado-multicloud-dx:v3",
                    "copado__Options__c": "[ ]",
                    "copado__Parameters__c": "[ {\n  \"required\" : true,\n  \"name\" : \"source_sessionid\",\n  \"defaultValue\" : \"{$Source.Credential.SessionId}\"\n}, {\n  \"required\" : true,\n  \"name\" : \"source_endpoint\",\n  \"defaultValue\" : \"{$Source.Credential.Endpoint}\"\n}, {\n  \"required\" : true,\n  \"name\" : \"source_env_var\",\n  \"defaultValue\" : \"{$Source.apex.EnvironmentVariables}\"\n}, {\n  \"required\" : true,\n  \"name\" : \"destination_env_var\",\n  \"defaultValue\" : \"{$Destination.apex.EnvironmentVariables}\"\n}, {\n  \"required\" : true,\n  \"name\" : \"destination_sessionid\",\n  \"defaultValue\" : \"{$Destination.Credential.SessionId}\"\n}, {\n  \"required\" : true,\n  \"name\" : \"destination_endpoint\",\n  \"defaultValue\" : \"{$Destination.Credential.Endpoint}\"\n}, {\n  \"required\" : false,\n  \"name\" : \"records\",\n  \"defaultValue\" : \"\"\n}, {\n  \"required\" : false,\n  \"name\" : \"custom_setting_name\",\n  \"defaultValue\" : \"\"\n}, {\n  \"required\" : false,\n  \"name\" : \"profiles\",\n  \"defaultValue\" : \"\"\n}, {\n  \"required\" : false,\n  \"name\" : \"users\",\n  \"defaultValue\" : \"\"\n}, {\n  \"required\" : false,\n  \"name\" : \"organizations\",\n  \"defaultValue\" : \"\"\n}, {\n  \"required\" : false,\n  \"name\" : \"key_prefix\",\n  \"defaultValue\" : \"\"\n}, {\n  \"required\" : true,\n  \"name\" : \"isValidation\",\n  \"defaultValue\" : \"{$Context.JobExecution__r.DataJson.deploymentDryRun}\"\n} ]",
                    "copado__Script__c": "#!/usr/bin/env node\n/**\n * Performs deployment of custom setting records.\n * @param source_sessionid\n * @param source_endpoint\n * @param source_env_var\n * @param destination_env_var\n * @param destination_sessionid\n * @param destination_endpoint\n * @param records\n * @param custom_setting_name\n * @param profiles\n * @param users\n * @param organizations\n * @param key_prefix\n * @param isValidation\n */\n\nconst fs = require('fs'),\n    { execSync, exec } = require('child_process'),\n    {\n        source_sessionid,\n        source_endpoint,\n        source_env_var,\n        destination_env_var,\n        destination_sessionid,\n        destination_endpoint,\n        custom_setting_name,\n        isValidation\n    } = process.env,\n    sourceApiVersion = '55.0',\n    source_base_url = getBaseUrl(source_endpoint),\n    destination_base_url = getBaseUrl(destination_endpoint),\n    source_environment = 'source',\n    destination_environment = 'destination';\n\nlet { records, profiles, users, organizations, key_prefix } = process.env,\n    profileQuery,\n    userQuery,\n    organizationQuery,\n    recordNames,\n    sourceCustomSetting = {},\n    sourceRecords = {\n        profileMapping: {},\n        userMapping: {},\n        organizationMapping: {},\n        records: []\n    },\n    destinationRecords = {\n        profileMapping: {},\n        userMapping: {},\n        organizationMapping: {},\n        records: {}\n    };\n\n// EXECUTION\n\nexecute();\n\n// FUNCTIONS\n\nfunction execute() {\n    try {\n        validateExecutionMode();\n        setup();\n        validateSource();\n        prepareQueryForDependentRecords();\n        Promise.all(getCustomSettingDependentData(source_sessionid, `Retrieve records from ${source_environment}`))\n            .then((data) => {\n                queryCustomSettingInSource(data);\n                validateDestination();\n                Promise.all(getCustomSettingDependentData(destination_sessionid, `Retrieve records from ${destination_environment}`))\n                    .then((data) => {\n                        queryCustomSettingInDestination(data);\n                        mergeAndDeployRecords();\n                    })\n                    .catch((error) => {\n                        logError(error);\n                    });\n            })\n            .catch((error) => {\n                logError(error);\n            });\n    } catch (error) {\n        logError(error);\n    }\n}\n\nfunction getBaseUrl(endpoint) {\n    return endpoint.substring(0, endpoint.indexOf('/', endpoint.indexOf('/') + 2));\n}\n\nfunction validateExecutionMode() {\n    const validationModeMessage = 'This step will not be executed for validate changes';\n    if (isValidation === 'true') {\n        execSync(`copado -p '${validationModeMessage}' --result-data '${validationModeMessage}'`);\n        process.exit(0);\n    }\n}\n\nfunction logError(error) {\n    execSync(`copado -p 'Error' -e '${error.toString()}' && exit 1`);\n}\n\nfunction setup() {\n    const cmd = `\n copado -p 'Preparing sfdx project configuration'\n cd /app\n sfdx force:project:create --projectname 'sfdx_project' --json\n `;\n    execSync(cmd, { stdio: 'inherit' });\n    let projectJson = fs.readFileSync('/app/sfdx_project/sfdx-project.json')?.toString();\n    if (projectJson) {\n        projectJson = JSON.parse(projectJson);\n        if(projectJson.sourceApiVersion !== sourceApiVersion) {\n        \tprojectJson = { ...projectJson, sourceApiVersion };\n        \tfs.writeFileSync('/app/sfdx_project/sfdx-project.json', JSON.stringify(projectJson));\n        }\n    }\n}\n\nfunction setInstanceUrl(url, message) {\n    const cmd = `\n copado -p '${message}'\n cd /app/sfdx_project\n sfdx config:set instanceUrl=${url}\n `;\n    execSync(cmd, { stdio: 'inherit' });\n}\n\nfunction retrieveCustomSettingMetadata(sessionid, message, environment) {\n    let result;\n    if (!custom_setting_name) {\n        throw `Error occured (${environment}), invalid custom setting name. Please check logs for more details.`;\n    }\n    const cmd = `\n copado -p '${message}'\n cd /app/sfdx_project\n sfdx force:source:retrieve --metadata CustomObject:${custom_setting_name} -u ${sessionid} --json`;\n    const response = execSync(cmd);\n    if (!response) {\n        throw `Error occured (${environment}), custom setting metadata retrieval failed. Please check logs for more details.`;\n    } else {\n        result = extractCustomSettingMetadata(JSON.parse(response.toString()), environment);\n    }\n    return result;\n}\n\nfunction extractCustomSettingMetadata(metadataResponse, environment) {\n    const result = { fields: [], filePath: '' };\n    const metadata = metadataResponse?.result?.inboundFiles;\n    if (metadataResponse.status != 0 || !metadata) {\n        throw `Error occured (${environment}), '${JSON.stringify(metadataResponse)}'. Please check logs for more details.`;\n    } else {\n        metadata.forEach((element) => {\n            if (element.error) {\n                throw `Error occured (${environment}), '${JSON.stringify(element.error)}'. Please check logs for more details.`;\n            } else if (element.type === 'CustomField') {\n                result.fields.push(element.fullName.replace(`${custom_setting_name}.`, ''));\n            } else if (element.type === 'CustomObject') {\n                result.filePath = element.filePath;\n            }\n        });\n    }\n    return result;\n}\n\nfunction checkCustomSettingTypeAndVisibility(customSettingPath, message, environment) {\n    const result = { isHierarchy: false };\n    if (!customSettingPath) {\n        throw `Error occured (${environment}), invalid custom setting filePath. Please check logs for more details.`;\n    }\n    const cmd = `\n copado -p '${message}'\n cd /app/sfdx_project\n cat ${customSettingPath}\n `;\n    let response = execSync(cmd);\n    if (!response) {\n        throw `Error occured (${environment}), custom setting details not found. Please check logs for more details.`;\n    } else {\n        response = response.toString();\n        if (!response.includes('<visibility>Public</visibility>')) {\n            throw `Error occured (${environment}), '${JSON.stringify(\n                response\n            )}'. Only public custom setting records can be moved from source org to destination org. Please check logs for more details.`;\n        }\n        result.isHierarchy = response.includes('<customSettingsType>Hierarchy</customSettingsType>');\n    }\n    return result;\n}\n\nfunction validateSource() {\n    setInstanceUrl(source_base_url, `Setting instance url to ${source_environment}`);\n    const metadata = retrieveCustomSettingMetadata(\n        source_sessionid,\n        `Retrieve and validate custom setting in ${source_environment}`,\n        source_environment\n    );\n    Object.assign(sourceCustomSetting, metadata);\n    const type = checkCustomSettingTypeAndVisibility(\n        sourceCustomSetting.filePath,\n        `Checking custom setting type and visibility in ${source_environment}`,\n        source_environment\n    );\n    Object.assign(sourceCustomSetting, type);\n}\n\nfunction prepareQueryForDependentRecords() {\n    const hierarchyCustomSettingError = `Error occured, for hierarchy custom setting we need profile, user or organization record(s) to deploy the custom setting data. Please check logs for more details.`;\n    const listCustomSettingError = `Error occured, no custom setting record(s) found for deployment. Please check logs for more details.`;\n    if (sourceCustomSetting.isHierarchy) {\n        if (!profiles && !users && !organizations) {\n            throw hierarchyCustomSettingError;\n        }\n        profiles = JSON.parse(profiles);\n        users = JSON.parse(users);\n        organizations = JSON.parse(organizations);\n        if (profiles?.length) {\n            profileQuery = `SELECT Id, Name FROM Profile WHERE Name IN ('${profiles.map((profile) => profile.Name).join(\"','\")}')`;\n        }\n        if (users?.length) {\n            const userNames = [];\n            const userProfileNames = [];\n            users.forEach((user) => {\n                userNames.push(user.Name);\n                userProfileNames.push(user.Profile.Name);\n            });\n            userQuery = `SELECT Id, Name FROM User WHERE Name IN ('${userNames.join(\"','\")}') AND Profile.Name IN ('${userProfileNames.join(\n                \"','\"\n            )}')`;\n        }\n        if (organizations?.length) {\n            organizationQuery = `SELECT Id, Name FROM Organization WHERE Name IN ('${organizations\n                .map((organization) => organization.Name)\n                .join(\"','\")}')`;\n        }\n        if (!profileQuery && !userQuery && !organizationQuery) {\n            throw hierarchyCustomSettingError;\n        }\n    } else if (!records) {\n        throw listCustomSettingError;\n    } else {\n        records = JSON.parse(records);\n        if (!records?.length) {\n            throw listCustomSettingError;\n        } else {\n            recordNames = records.map((record) => record.Name);\n        }\n    }\n}\n\nfunction queryCustomSettingInSource(data) {\n    const filterResponse = prepareCustomSettingQueryFilter(data, sourceCustomSetting.isHierarchy, 'Id', 'Name', source_environment);\n    Object.assign(sourceRecords, filterResponse);\n    delete sourceRecords.customSettingNames;\n    const queryResponse = queryCustomSettingRecords(\n        sourceCustomSetting.isHierarchy,\n        Object.keys(sourceRecords.profileMapping),\n        Object.keys(sourceRecords.userMapping),\n        Object.keys(sourceRecords.organizationMapping),\n        filterResponse.customSettingNames,\n        `Error occured, no filters avaliable to query custom seting records in ${source_environment}. Please check logs for more details.`,\n        sourceCustomSetting.fields,\n        source_sessionid,\n        source_environment\n    );\n    sourceRecords.records = getCustomSettingRecords(\n        JSON.parse(queryResponse),\n        source_environment,\n        `Error occured, there are no custom setting records available in ${source_environment} as per the mentioned filters. Please check logs for more details.`\n    );\n}\n\nfunction getCustomSettingRecords(data, environment, noRecordsError) {\n    let result;\n    if (data.status != 0) {\n        throw `Error occured (${environment}), '${JSON.stringify(data)}' Please check logs for more details.`;\n    } else {\n        result = data?.result?.records;\n        if (!records?.length && noRecordsError) {\n            throw noRecordsError;\n        }\n    }\n    return result;\n}\n\nfunction prepareCustomSettingQueryFilter(data, isHierarchy, key, value, environment) {\n    const result = { profileMapping: {}, userMapping: {}, organizationMapping: {}, customSettingNames: null };\n    data.forEach((response) => {\n        if (isHierarchy) {\n            response = JSON.parse(response);\n            if (response.status != 0) {\n                throw `Error occured (${environment}), '${JSON.stringify(response)}'. Please check logs for more details.`;\n            } else {\n                const records = response?.result?.records;\n                if (records?.length) {\n                    mapRecords(records, result, key, value);\n                }\n            }\n        } else {\n            result.customSettingNames = response;\n        }\n    });\n    return result;\n}\n\nfunction queryCustomSettingRecords(\n    isHierarchy,\n    profileIds,\n    userIds,\n    orgIds,\n    customSettingNames,\n    noFilterError,\n    fieldsToQuery,\n    sessionid,\n    environment\n) {\n    let response;\n    let filters = [];\n    if (isHierarchy) {\n        filters = filters.concat(profileIds, userIds, orgIds);\n    } else {\n        filters = filters.concat(customSettingNames);\n    }\n\n    if (!filters?.length) {\n        if (noFilterError) {\n            throw noFilterError;\n        }\n    } else {\n        const filterIds = `('${filters.join(\"','\")}')`;\n        const query = `SELECT Id, Name, SetupOwnerId ${\n            fieldsToQuery?.length ? ',' + fieldsToQuery.join(',') : ''\n        } FROM ${custom_setting_name} WHERE ${isHierarchy ? 'SetupOwnerId IN ' : 'Name IN '} ${filterIds}`;\n        response = doSoqlSyncQuery(query, sessionid);\n    }\n\n    if (!response) {\n        throw `Error occured (${environment}), force:data:soql:query command failed. Please check logs for more details.`;\n    }\n    return response;\n}\n\nfunction mapRecords(records, dataSet, key, value) {\n    records.forEach((record) => {\n        switch (record?.attributes?.type) {\n            case 'Profile':\n                dataSet.profileMapping[record[key]] = record[value];\n                break;\n            case 'User':\n                dataSet.userMapping[record[key]] = record[value];\n                break;\n            case 'Organization':\n                dataSet.organizationMapping[record[key]] = record[value];\n                break;\n        }\n    });\n}\n\nfunction getCustomSettingDependentData(sessionId, message) {\n    exec(`copado -p '${message}'`, { stdio: 'inherit' });\n    const promises = [];\n    if (sourceCustomSetting.isHierarchy) {\n        [profileQuery, userQuery, organizationQuery].forEach((query) => {\n            if (query) {\n                promises.push(\n                    new Promise((resolve, reject) => {\n                        doSoqlAsyncQuery(resolve, reject, query, sessionId);\n                    })\n                );\n            }\n        });\n    } else {\n        promises.push(\n            new Promise((resolve, reject) => {\n                resolve(recordNames);\n            })\n        );\n    }\n    return promises;\n}\n\nfunction doSoqlAsyncQuery(resolve, reject, query, sessionId) {\n    exec(getQueryCmd(query, sessionId), (error, data, stderr) => {\n        if (error) {\n            reject(error);\n        } else {\n            resolve(data);\n        }\n    });\n}\n\nfunction doSoqlSyncQuery(query, sessionId) {\n    const response = execSync(getQueryCmd(query, sessionId));\n    if (!response) {\n        throw `Error occured, force:data:soql:query command failed. Please check logs for more details.`;\n    } else {\n        return response.toString();\n    }\n}\n\nfunction getQueryCmd(query, sessionId) {\n    return `\n cd /app/sfdx_project\n sfdx force:data:soql:query --query \"${query}\" --json -u ${sessionId}\n `;\n}\n\nfunction validateDestination() {\n    setInstanceUrl(destination_base_url, `Setting instance url to ${destination_environment}`);\n    const metadata = retrieveCustomSettingMetadata(\n        destination_sessionid,\n        `Retrieve and validate custom setting in ${destination_environment}`,\n        destination_environment\n    );\n    const missingFields = sourceCustomSetting.fields.filter((field) => metadata.fields.indexOf(field) === -1);\n    if (missingFields?.length) {\n        throw `Error occured, fields missing in ${destination_environment} ${missingFields.join(',')}. Please check logs for more details.`;\n    }\n    const type = checkCustomSettingTypeAndVisibility(\n        metadata.filePath,\n        `Checking custom setting type and visibility in ${destination_environment}`,\n        destination_environment\n    );\n    if (sourceCustomSetting.isHierarchy != type.isHierarchy) {\n        throw `Error occured, there is a mismatch in the custom setting type for source and destination. Please check logs for more details.`;\n    }\n}\n\nfunction queryCustomSettingInDestination(data) {\n    const filterResponse = prepareCustomSettingQueryFilter(data, sourceCustomSetting.isHierarchy, 'Name', 'Id', destination_environment);\n    Object.assign(destinationRecords, filterResponse);\n    delete destinationRecords.customSettingNames;\n    const queryResponse = queryCustomSettingRecords(\n        sourceCustomSetting.isHierarchy,\n        Object.values(destinationRecords.profileMapping),\n        Object.values(destinationRecords.userMapping),\n        Object.values(destinationRecords.organizationMapping),\n        filterResponse.customSettingNames,\n        null,\n        null,\n        destination_sessionid,\n        destination_environment\n    );\n    const records = getCustomSettingRecords(JSON.parse(queryResponse), destination_environment, null);\n    records.forEach((record) => {\n        destinationRecords.records[sourceCustomSetting.isHierarchy ? record.SetupOwnerId : record.Name] = record.Id;\n    });\n}\n\nfunction mergeAndDeployRecords() {\n    const finalRecords = mergeRecords();\n    createCSV(finalRecords);\n    varreplace();\n    deployRecords();\n}\n\nfunction mergeRecords() {\n    const finalRecords = [];\n    key_prefix = JSON.parse(key_prefix);\n    let destinationSetupOwnerId;\n    sourceRecords.records.forEach((record) => {\n        if (sourceCustomSetting.isHierarchy) {\n            destinationSetupOwnerId = null;\n            switch (key_prefix[record.SetupOwnerId.substring(0, 3)]) {\n                case 'Profile':\n                    destinationSetupOwnerId = destinationRecords.profileMapping[sourceRecords.profileMapping[record.SetupOwnerId]];\n                    break;\n                case 'User':\n                    destinationSetupOwnerId = destinationRecords.userMapping[sourceRecords.userMapping[record.SetupOwnerId]];\n                    break;\n                case 'Organization':\n                    destinationSetupOwnerId =\n                        destinationRecords.organizationMapping[sourceRecords.organizationMapping[record.SetupOwnerId]];\n                    break;\n            }\n            if (!destinationSetupOwnerId) {\n                return;\n            }\n        } else {\n            destinationSetupOwnerId = null;\n        }\n        delete record.attributes;\n        record.SetupOwnerId = destinationSetupOwnerId;\n        record.Id = sourceCustomSetting.isHierarchy\n            ? destinationRecords.records[destinationSetupOwnerId]\n            : destinationRecords.records[record.Name];\n        finalRecords.push(record);\n    });\n    return finalRecords;\n}\n\nfunction createCSV(finalRecords) {\n    if (!finalRecords?.length) {\n        throw `No custom setting records avaliable for deployment in ${destination_environment}`;\n    } else {\n        const csvData = arrayToCSV(finalRecords);\n        fs.writeFileSync('/tmp/records.csv', csvData);\n    }\n}\n\nfunction arrayToCSV(data) {\n    let csv = data.map((row) => Object.values(row));\n    csv.unshift(Object.keys(data[0]));\n    return `\"${csv.join('\"\\n\"').replace(/,/g, '\",\"')}\"`;\n}\n\nfunction varreplace() {\n    const cmd = `\n copado -p \"Replacing environment variables, if any\"\n varreplace '${source_env_var}' '/tmp/records.csv' --valuename=true\n varreplace '${destination_env_var}' '/tmp/records.csv' --valuename=false\n `;\n    execSync(cmd);\n}\n\nfunction deployRecords() {\n    sourceCustomSetting = sourceRecords = destinationRecords = profileQuery = userQuery = organizationQuery = recordNames = null;\n    const cmd = `\n cd /app/sfdx_project\n copado -p 'Deploying custom setting records in ${destination_environment}'\n sfdx force:data:bulk:upsert --sobjecttype ${custom_setting_name} --csvfile /tmp/records.csv --externalid Id -u ${destination_sessionid} --wait 60 > /tmp/result.txt\n copado -u /tmp/records.csv --name \"records.csv\"\n copado -u /tmp/result.txt --name \"result.txt\"\n `;\n    execSync(cmd, { maxBuffer: 50 * 1024 * 1024 });\n    const result = fs.readFileSync('/tmp/result.txt');\n    if (!result) {\n        throw 'Error occured while deploying records in destination, kindly check logs for more details';\n    } else if (result.includes('Upsert errors')) {\n        throw 'Error occured, kindly check the result.txt file for more details';\n    }\n}",
                    "copado__Timeout__c": 60,
                    "copado__Type__c": "Standard",
                    "copado__Version__c": "1",
                    "copado__Worker_Size__c": "M",
                    "Id": "a0k09000000rbjMAAQ",
                    "LastReferencedDate": "2022-06-27T07:34:47.000+0000",
                    "LastViewedDate": "2022-06-27T07:34:47.000+0000",
                    "Name": "SFDX Deploy Custom Setting"
                },
                {
                    "attributes": {
                        "type": "copado__Function__c",
                        "url": "/services/data/v56.0/sobjects/copado__Function__c/a0k0900000C7opaAAB"
                    },
                    "copado__ApexClass__c": "cmcSf.RefreshMetadataCallback",
                    "copado__API_Name__c": "SFDX_Refresh_Metadata",
                    "copado__Callback_Type__c": "ApexClass",
                    "copado__Description__c": "This function generates metadata and deleted metadata files for the Salesforce org",
                    "copado__Image_Name__c": "copado-multicloud-dx:v3",
                    "copado__Options__c": "[ ]",
                    "copado__Parameters__c": "[ {\n  \"required\" : true,\n  \"name\" : \"sessionId\",\n  \"defaultValue\" : \"{$Source.Credential.SessionId}\"\n}, {\n  \"required\" : true,\n  \"name\" : \"endpoint\",\n  \"defaultValue\" : \"{$Source.Credential.Endpoint}\"\n}, {\n  \"required\" : false,\n  \"name\" : \"metadataFileId\",\n  \"defaultValue\" : \"{$Context.JobExecution__r.DataJson.metadataFileId}\"\n}, {\n  \"name\" : \"ignoredType\",\n  \"defaultValue\" : \"{$Context.JobExecution__r.DataJson.ignoredType}\"\n}, {\n  \"name\" : \"typeFilter\",\n  \"defaultValue\" : \"{$Context.JobExecution__r.DataJson.typeFilter}\"\n}, {\n  \"name\" : \"maxBuffer\",\n  \"defaultValue\" : \"5242880\"\n} ]",
                    "copado__Script__c": "#!/usr/bin/env node\n/**\n * Generates metadata and deleted metadata files for the Salesforce org\n * @param sessionId\n * @param endpoint\n * @param metadataFileId\n * @param ignoredType\n * @param typeFilter\n * @param maxBuffer\n */\nconst { writeFileSync } = require('fs'),\n    { env, chdir, exit } = require('process'),\n    { spawnSync } = require('child_process'),\n    { sessionId, endpoint, metadataFileId, ignoredType, typeFilter, maxBuffer } = env,\n    MAX_BUFFER_SIZE = parseInt(maxBuffer),\n    METADATA_FILE = 'MetaData',\n    NEW_METADATA_FILE = 'NewMetaData',\n    DELETED_METADATA_FILE = 'DeletedMetaData',\n    IGNORED_TYPE_FILE = 'IgnoredType.json',\n    TYPE_FILTER_FILE = 'TypeFilter.json',\n    STDIO = {\n        INHERIT: 'inherit'\n    };\n\n// EXECUTION\n\nexecute();\n\n// FUNCTIONS\n\nfunction execute() {\n    try {\n        chdir('/tmp');\n        createFile(IGNORED_TYPE_FILE, ignoredType ? ignoredType : '[]');\n        createFile(TYPE_FILTER_FILE, typeFilter ? typeFilter : '[]');\n        generateMetadataFile(sessionId, endpoint);\n        findDeletedMetadata(metadataFileId);\n    } catch (error) {\n        logError(error);\n    }\n}\n\nfunction logError(error) {\n    executeCommand(getErrorCmdString(error.toString()));\n}\n\nfunction createFile(fileName, data) {\n    writeFileSync(fileName, data);\n}\n\nfunction generateMetadataFile(sessionId, endpoint) {\n    const metadataRetrieveCmd =\n        'metadata-retrieve ' +\n        buildParameters({\n            ignoredTypes: IGNORED_TYPE_FILE,\n            output: NEW_METADATA_FILE,\n            typeFilter: TYPE_FILTER_FILE\n        }) +\n        ' refresh ' +\n        buildParameters({\n            endpointUrl: sessionId,\n            sessionId: getBaseUrl(endpoint)\n        }) +\n        ' || ' +\n        getErrorCmdString('Error in generating metadata file');\n    generateFile('Generating Metadata File', metadataRetrieveCmd, NEW_METADATA_FILE, METADATA_FILE, 'Error in uploading metadata file');\n}\n\nfunction generateDeletedMetadataFile() {\n    const metadataRetrieveCmd =\n        'metadata-retrieve ' +\n        buildParameters({\n            ignoredTypes: IGNORED_TYPE_FILE,\n            output: DELETED_METADATA_FILE,\n            typeFilter: TYPE_FILTER_FILE\n        }) +\n        ` difference ${METADATA_FILE} ${NEW_METADATA_FILE}  || ` +\n        getErrorCmdString('Error in generating deleted metadata file');\n    generateFile(\n        'Generating Deleted Metadata File',\n        metadataRetrieveCmd,\n        DELETED_METADATA_FILE,\n        DELETED_METADATA_FILE,\n        'Error in uploading deleted metadata file'\n    );\n}\n\nfunction generateFile(progressMessage, metadataRetrieveCmd, filePath, fileName, fileUploadErrorMessage) {\n    const cmd = `\n         copado -p '${progressMessage}'\n         ${metadataRetrieveCmd}\n         copado -u ${filePath} -n ${fileName} || ${getErrorCmdString(fileUploadErrorMessage)}\n  `;\n    executeCommand(cmd, STDIO.INHERIT);\n}\n\nfunction getBaseUrl(endpoint) {\n    return endpoint.substring(0, endpoint.indexOf('/', endpoint.indexOf('/') + 2));\n}\n\nfunction findDeletedMetadata(metadataFileId) {\n    if (metadataFileId) {\n        downloadCredentialMetadataFile(metadataFileId);\n        generateDeletedMetadataFile();\n    }\n}\n\nfunction downloadCredentialMetadataFile(metadataFileId) {\n    executeCommand(\n        `copado --downloadfiles ${metadataFileId} || ${getErrorCmdString('Error in downloading credential metadata file')}`,\n        STDIO.INHERIT\n    );\n}\n\nfunction buildParameters(data) {\n    return Object.entries(data).reduce((parameters, [key, value]) => {\n        return parameters + (value ? ` --${key} ${value}` : '');\n    }, '');\n}\n\nfunction executeCommand(cmd, ioconfig) {\n    const options = {\n        shell: true,\n        maxBuffer: MAX_BUFFER_SIZE\n    };\n    if (ioconfig) {\n        options.stdio = ioconfig;\n    }\n    const response = spawnSync(cmd, options);\n    if (response?.stderr) {\n        throw response?.stderr;\n    } else if (response?.status === 1) {\n        exit(1);\n    }\n}\n\nfunction getErrorCmdString(error) {\n    const suffix = 'Please check the logs for details.';\n    return `{ copado -p 'Error' -e \"${error}. ${suffix}\"; exit 1; }`;\n}",
                    "copado__Type__c": "Standard",
                    "Id": "a0k0900000C7opaAAB",
                    "LastReferencedDate": "2022-12-20T06:35:41.000+0000",
                    "LastViewedDate": "2022-12-20T06:35:41.000+0000",
                    "Name": "SFDX Refresh Metadata"
                }
            ],
            "ObjectType": "copado__Function__c"
        },
        {
            "Records": [
                {
                    "attributes": {
                        "type": "copado__JobTemplate__c",
                        "url": "/services/data/v55.0/sobjects/copado__JobTemplate__c/a0u7Q000000Xw28QAC"
                    },
                    "copado__ApiName__c": "sfdx_commit_1",
                    "copado__Description__c": "<p>Standard job template to perform git commit in User Stories</p>",
                    "copado__Type__c": "Standard",
                    "copado__Version__c": 2,
                    "Id": "a0u7Q000000Xw28QAC",
                    "LastReferencedDate": "2022-09-15T06:40:09.000+0000",
                    "LastViewedDate": "2022-09-15T06:40:09.000+0000",
                    "Name": "SFDX Commit"
                },
                {
                    "attributes": {
                        "type": "copado__JobTemplate__c",
                        "url": "/services/data/v55.0/sobjects/copado__JobTemplate__c/a0u7Q000000Xw29QAC"
                    },
                    "copado__ApiName__c": "sfdx_deploy_1",
                    "copado__Description__c": "<p>DX Source Deployment</p>",
                    "copado__Type__c": "Standard",
                    "copado__Version__c": 1,
                    "copado__VolumeOptions__c": "[\n    {\n        \"name\": \"volumeSize\",\n        \"value\": \"10\"\n    },\n    {\n        \"name\": \"volumeTTL\",\n        \"value\": \"100\"\n    },\n    {\n        \"name\": \"preserveVolumeAfterExecution\",\n        \"value\": \"true\"\n    },\n    {\n        \"name\": \"volumeEnabled\",\n        \"value\": \"true\"\n    }\n]",
                    "Id": "a0u7Q000000Xw29QAC",
                    "LastReferencedDate": "2022-09-15T06:40:13.000+0000",
                    "LastViewedDate": "2022-09-15T06:40:13.000+0000",
                    "Name": "SFDX Deploy"
                },
                {
                    "attributes": {
                        "type": "copado__JobTemplate__c",
                        "url": "/services/data/v55.0/sobjects/copado__JobTemplate__c/a0u7Q000000Xw2AQAS"
                    },
                    "copado__ApiName__c": "sfdx_promote_1",
                    "copado__Description__c": "<p>DX Source Promote</p>",
                    "copado__Type__c": "Standard",
                    "copado__Version__c": 1,
                    "Id": "a0u7Q000000Xw2AQAS",
                    "LastReferencedDate": "2022-09-15T06:40:13.000+0000",
                    "LastViewedDate": "2022-09-15T06:40:13.000+0000",
                    "Name": "SFDX Promote"
                },
                {
                    "attributes": {
                      "type": "copado__JobTemplate__c",
                      "url": "/services/data/v57.0/sobjects/copado__JobTemplate__c/a0u7Q0000004wGoQAI"
                    },
                    "copado__ApiName__c": "SFDX Package Distribution_1",
                    "copado__Type__c": "Standard",
                    "copado__Version__c": 1,
                    "Id": "a0u7Q0000004wGoQAI",
                    "LastReferencedDate": "2023-02-02T08:22:48.000+0000",
                    "LastViewedDate": "2023-02-02T08:22:48.000+0000",
                    "Name": "SFDX Package Distribution"
                  },
                {
                    "attributes": {
                        "type": "copado__JobTemplate__c",
                        "url": "/services/data/v52.0/sobjects/copado__JobTemplate__c/a0t09000002vfccAAA"
                    },
                    "copado__ApiName__c": "SFDX Package Import_1",
                    "copado__Type__c": "Standard",
                    "copado__Version__c": 1,
                    "CreatedDate": "2021-09-17T14:07:46.000+0000",
                    "Id": "a0t09000002vfccAAA",
                    "IsDeleted": false,
                    "LastModifiedDate": "2021-10-04T09:11:43.000+0000",
                    "LastReferencedDate": "2021-10-04T09:11:43.000+0000",
                    "LastViewedDate": "2021-10-04T09:11:43.000+0000",
                    "Name": "SFDX Package Import",
                    "SystemModstamp": "2021-10-04T09:11:43.000+0000"
                },
                {
                    "attributes": {
                        "type": "copado__JobTemplate__c",
                        "url": "/services/data/v56.0/sobjects/copado__JobTemplate__c/a0u7Q0000004wGqQAI"
                    },
                    "copado__ApiName__c": "SFDX Package Version Publish_1",
                    "copado__Type__c": "Standard",
                    "copado__Version__c": 1,
                    "Id": "a0u7Q0000004wGqQAI",
                    "LastReferencedDate": "2023-01-19T12:11:24.000+0000",
                    "LastViewedDate": "2023-01-19T12:11:24.000+0000",
                    "Name": "SFDX Package Version Publish"
                },
                {
                    "attributes": {
                        "type": "copado__JobTemplate__c",
                        "url": "/services/data/v56.0/sobjects/copado__JobTemplate__c/a0u7Q0000004wGrQAI"
                    },
                    "copado__ApiName__c": "SFDX Package Version Update_1",
                    "copado__Type__c": "Standard",
                    "copado__Version__c": 1,
                    "Id": "a0u7Q0000004wGrQAI",
                    "LastReferencedDate": "2022-09-27T13:29:50.000+0000",
                    "LastViewedDate": "2022-09-27T13:29:50.000+0000",
                    "Name": "SFDX Package Version Update"
                },
                {
                    "attributes": {
                        "type": "copado__JobTemplate__c",
                        "url": "/services/data/v56.0/sobjects/copado__JobTemplate__c/a0u7Q0000004wGsQAI"
                    },
                    "copado__ApiName__c": "SFDX Package Version Create_1",
                    "copado__Description__c": "<p>Creates Package Version</p>",
                    "copado__Type__c": "Standard",
                    "copado__Version__c": 1,
                    "Id": "a0u7Q0000004wGsQAI",
                    "LastReferencedDate": "2022-09-16T12:40:16.000+0000",
                    "LastViewedDate": "2022-09-16T12:40:16.000+0000",
                    "Name": "SFDX Package Version Create"
                },
                {
                    "attributes": {
                        "type": "copado__JobTemplate__c",
                        "url": "/services/data/v56.0/sobjects/copado__JobTemplate__c/a0u7Q0000004wGtQAI"
                    },
                    "copado__ApiName__c": "SFDX Package Create_1",
                    "copado__Description__c": "<p>Creates Package</p>",
                    "copado__Type__c": "Standard",
                    "copado__Version__c": 1,
                    "Id": "a0u7Q0000004wGtQAI",
                    "LastReferencedDate": "2023-01-03T11:11:02.000+0000",
                    "LastViewedDate": "2023-01-03T11:11:02.000+0000",
                    "Name": "SFDX Package Create"
                },
                {
                    "attributes": {
                        "type": "copado__JobTemplate__c",
                        "url": "/services/data/v54.0/sobjects/copado__JobTemplate__c/a0u7Q000000XrrkQAC"
                    },
                    "copado__ApiName__c": "SFDX Run Apex Tests_1",
                    "copado__Type__c": "Standard",
                    "copado__Version__c": 1,
                    "Id": "a0u7Q000000XrrkQAC",
                    "LastReferencedDate": "2022-04-21T10:30:02.000+0000",
                    "LastViewedDate": "2022-04-21T10:30:02.000+0000",
                    "Name": "SFDX Run Apex Tests"
                },
                {
                    "attributes": {
                        "type": "copado__JobTemplate__c",
                        "url": "/services/data/v56.0/sobjects/copado__JobTemplate__c/a0u7Q0000004yiqQAA"
                    },
                    "copado__ApiName__c": "SFDX Package Version Git Configure_1",
                    "copado__Description__c": "<p><span style=\"font-size: 14px;\">SFDX Package Version Git Configure</span></p>",
                    "copado__Type__c": "Standard",
                    "copado__Version__c": 1,
                    "Id": "a0u7Q0000004yiqQAA",
                    "LastReferencedDate": "2023-01-22T12:12:15.000+0000",
                    "LastViewedDate": "2023-01-22T12:12:15.000+0000",
                    "Name": "SFDX Package Version Git Configure"
                },
                {
                    "attributes": {
                        "type": "copado__JobTemplate__c",
                        "url": "/services/data/v55.0/sobjects/copado__JobTemplate__c/a0t09000000lkYtAAI"
                    },
                    "copado__ApiName__c": "SFDX Test Records Creation In User Story_1",
                    "copado__Type__c": "Standard",
                    "copado__Version__c": 1,
                    "Id": "a0t09000000lkYtAAI",
                    "LastReferencedDate": "2022-07-11T06:25:51.000+0000",
                    "LastViewedDate": "2022-07-11T06:25:51.000+0000",
                    "Name": "SFDX Test Records Creation In User Story"
                },
                {
                    "attributes": {
                        "type": "copado__JobTemplate__c",
                        "url": "/services/data/v56.0/sobjects/copado__JobTemplate__c/a0t09000000llqoAAA"
                    },
                    "copado__ApiName__c": "SFDX Refresh Metadata_1",
                    "copado__Description__c": "<p><span style=\"font-size: 14px;\">Standard job template to refresh metadata cache of the org</span></p>",
                    "copado__Type__c": "Standard",
                    "copado__Version__c": 1,
                    "Id": "a0t09000000llqoAAA",
                    "LastReferencedDate": "2022-12-08T07:33:18.000+0000",
                    "LastViewedDate": "2022-12-08T07:33:18.000+0000",
                    "Name": "SFDX Refresh Metadata"
                }
            ],
            "ObjectType": "copado__JobTemplate__c"
        },
        {
            "Records": [
                {
                    "attributes": {
                      "type": "copado__JobStep__c",
                      "url": "/services/data/v57.0/sobjects/copado__JobStep__c/a0t7Q0000087w6YQAQ"
                    },
                    "copado__ApiName__c": "SFDX Package Distribution_Install package",
                    "copado__ConfigJson__c": "{\"functionName\":\"sfdx_install_package\",\"parameters\":[{\"name\":\"packages\",\"value\":\"{$Job.PrevStep.Result__r.Result_Data__c}\",\"required\":true},{\"name\":\"destinationBaseUrl\",\"value\":\"{$Destination.Credential.Endpoint}\",\"required\":true},{\"name\":\"destinationSession\",\"value\":\"{$Destination.Credential.SessionId}\",\"required\":true},{\"name\":\"wait\",\"value\":\"200\",\"required\":false},{\"name\":\"apiVersion\",\"value\":\"{$Context.JobExecution__r.DataJson.apiVersion}\"},{\"name\":\"devhubSession\",\"value\":\"{$Source.Credential.SessionId}\"},{\"name\":\"devhubBaseUrl\",\"value\":\"{$Source.Credential.Endpoint}\"},{\"name\":\"installationSecurityType\",\"value\":\"{$Context.JobExecution__r.DataJson.installSecurityType}\"}]}",
                    "copado__CustomType__c": "Function",
                    "copado__JobTemplate__c": "a0u7Q0000004wGoQAI",
                    "copado__Order__c": 3,
                    "copado__Type__c": "Function",
                    "Id": "a0t7Q0000087w6YQAQ",
                    "Name": "Install package"
                  },
                  {
                    "attributes": {
                      "type": "copado__JobStep__c",
                      "url": "/services/data/v57.0/sobjects/copado__JobStep__c/a0t7Q0000087w6ZQAQ"
                    },
                    "copado__ApiName__c": "SFDX Package Distribution_Get Dependencies",
                    "copado__ConfigJson__c": "{\"functionName\":\"SFDX_Get_Package_Version_Dependencies\",\"parameters\":[{\"name\":\"endpoint\",\"value\":\"{$Source.Credential.Endpoint}\",\"required\":true},{\"name\":\"session\",\"value\":\"{$Source.Credential.SessionId}\",\"required\":true},{\"name\":\"subscriberVersionId\",\"value\":\"{$Context.JobExecution__r.DataJson.subscriberId}\",\"required\":true},{\"name\":\"installationKey\",\"value\":\"{$Context.JobExecution__r.DataJson.installationKey}\",\"required\":false}]}",
                    "copado__CustomType__c": "Function",
                    "copado__JobTemplate__c": "a0u7Q0000004wGoQAI",
                    "copado__Order__c": 1,
                    "copado__Type__c": "Function",
                    "Id": "a0t7Q0000087w6ZQAQ",
                    "Name": "Get Dependencies"
                  },
                  {
                    "attributes": {
                      "type": "copado__JobStep__c",
                      "url": "/services/data/v57.0/sobjects/copado__JobStep__c/a0t7Q0000087w6aQAA"
                    },
                    "copado__ApiName__c": "SFDX Package Distribution_Get Keys",
                    "copado__ConfigJson__c": "{\"flowName\":\"cmcSf.GetPackageVersionWithKey\",\"parameters\":[{\"name\":\"subscriberVersionId\",\"value\":\"{$Context.JobExecution__r.DataJson.subscriberId}\"},{\"name\":\"versionDetails\",\"value\":\"{$Job.PrevStep.Result__r.Result_Data__c}\"}]}",
                    "copado__CustomType__c": "Salesforce Flow",
                    "copado__JobTemplate__c": "a0u7Q0000004wGoQAI",
                    "copado__Order__c": 2,
                    "copado__Type__c": "Flow",
                    "Id": "a0t7Q0000087w6aQAA",
                    "Name": "Get Keys"
                  },
                  {
                    "attributes": {
                      "type": "copado__JobStep__c",
                      "url": "/services/data/v57.0/sobjects/copado__JobStep__c/a0t7Q000000NQaAQAW"
                    },
                    "copado__ApiName__c": "SFDX Commit_Commit",
                    "copado__ConfigJson__c": "{\"functionName\":\"sfdx_commit\",\"parameters\":[{\"name\":\"fileChangesId\",\"value\":\"{$Context.JobExecution__r.DataJson.fileWithSelectedChanges}\",\"required\":true},{\"name\":\"fileName\",\"value\":\"Copado Commit changes\",\"required\":true},{\"name\":\"sourceSessionId\",\"value\":\"{$Source.Credential.SessionId}\",\"required\":true},{\"name\":\"sourceEndPoint\",\"value\":\"{$Source.Credential.Endpoint}\",\"required\":true},{\"name\":\"namespace\",\"value\":\"\"},{\"name\":\"git_json\",\"value\":\"{$Context.Repository.Credential}\",\"required\":true},{\"name\":\"baseBranch\",\"value\":\"{$Context.JobExecution__r.DataJson.baseBranch}\",\"required\":true},{\"name\":\"sourceEnv\",\"value\":\"{$Source.apex.EnvironmentVariables}\",\"required\":true},{\"name\":\"findAndReplaceFileId\",\"value\":\"{$Context.apex.GlobalFindAndReplaceSourceId}\",\"required\":false},{\"name\":\"featureBranch\",\"value\":\"{$Context.JobExecution__r.DataJson.featureBranchName}\",\"required\":true},{\"name\":\"recreateIfExists\",\"value\":\"{$Context.JobExecution__r.DataJson.recreateFeatureBranch}\",\"required\":true},{\"name\":\"commitMessage\",\"value\":\"{$Context.JobExecution__r.DataJson.message}\",\"required\":true},{\"name\":\"gitEmail\",\"value\":\"{$User.Email}\",\"required\":true},{\"name\":\"gitName\",\"value\":\"{$User.Name}\",\"required\":true},{\"name\":\"sourceEnvironmentBranch\",\"value\":\"{$Context.apex.SourceEnvironmentBranch}\",\"required\":true},{\"name\":\"gitDepth\",\"value\":\"100\"},{\"name\":\"timeout\",\"value\":\"180000\"},{\"name\":\"chunkSize\",\"value\":\"10\"},{\"name\":\"maxBuffer\",\"value\":\"5242880\"},{\"name\":\"overriddenApiVersion\",\"value\":\"\"}]}",
                    "copado__CustomType__c": "Function",
                    "copado__JobTemplate__c": "a0u7Q000000Xw28QAC",
                    "copado__Order__c": 1,
                    "copado__Type__c": "Function",
                    "Id": "a0t7Q000000NQaAQAW",
                    "Name": "Commit"
                },
                {
                    "attributes": {
                        "type": "copado__JobStep__c",
                        "url": "/services/data/v56.0/sobjects/copado__JobStep__c/a0t7Q000000N7q0QAC"
                    },
                    "copado__ApiName__c": "sfdx_deploy_sfdx_deploy",
                    "copado__ConfigJson__c": "{\"functionName\":\"sfdx_deploy\",\"parameters\":[{\"name\":\"file_changes_id\",\"value\":\"{$Context.JobExecution__r.DataJson.fileWithSelectedChanges}\",\"required\":true},{\"name\":\"promotion\",\"value\":\"{$Context.JobExecution__r.DataJson.promotionBranchName}\",\"required\":true},{\"name\":\"target_branch\",\"value\":\"{$Context.JobExecution__r.DataJson.destinationBranchName}\",\"required\":true},{\"name\":\"destinationInstanceUrl\",\"value\":\"{$Destination.Credential.Endpoint}\",\"required\":true},{\"name\":\"destinationSessionid\",\"value\":\"{$Destination.Credential.SessionId}\",\"required\":true},{\"name\":\"git_json\",\"value\":\"{$Context.Repository.Credential}\",\"required\":true},{\"name\":\"destination_env\",\"value\":\"{$Destination.apex.EnvironmentVariables}\",\"required\":true},{\"name\":\"find_and_replace_rules\",\"value\":\"{$Context.apex.GlobalFindAndReplaceDestinationId}\"},{\"name\":\"conflict_resolution_attachments\",\"value\":\"{$Context.apex.GetConflictResolutionAttachments}\",\"required\":true},{\"name\":\"deploy_id\",\"value\":\"{$Job.ExecutionParent.Id}\",\"required\":true},{\"name\":\"isValidation\",\"value\":\"{$Context.JobExecution__r.DataJson.deploymentDryRun}\",\"required\":true},{\"name\":\"git_name\",\"value\":\"{$User.Name}\"},{\"name\":\"git_email\",\"value\":\"{$User.Email}\"},{\"name\":\"repository_id\",\"value\":\"{$Pipeline.Git_Repository__r.Id}\"},{\"name\":\"testLevel\",\"value\":\"{$Job.ExecutionParent.Promotion__r.cmcSf__Apex_Test_Level__c}\"},{\"name\":\"testOnlyClasses\",\"value\":\"{$Context.apex.cmcSf.GetTestOnlyClasses}\"},{\"name\":\"debugMode\",\"value\":\"{$Job.ExecutionParent.Promotion__r.cmcSf__Debug_Mode__c}\"},{\"name\":\"git_depth\",\"value\":\"100\"},{\"name\":\"validationId\",\"value\":\"{$Job.ExecutionParent.Promotion__r.cmcSf__Validate_Deploy_Request_Id__c}\"},{\"name\":\"testClasses\",\"value\":\"{$Context.apex.cmcSf.GetTestClasses}\"},{\"name\":\"maxBuffer\",\"value\":\"5242880\"},{\"name\":\"waitTime\",\"value\":\"220\"},{\"name\":\"sourceInstanceUrl\",\"value\":\"{$Source.Credential.Endpoint}\"},{\"name\":\"sourceSessionid\",\"value\":\"{$Source.Credential.SessionId}\"},{\"name\":\"mergeProfile\",\"value\":\"false\"},{\"name\":\"overriddenApiVersion\",\"value\":\"\"}]}",
                    "copado__CustomType__c": "Function",
                    "copado__JobTemplate__c": "a0u7Q000000Xw29QAC",
                    "copado__Order__c": 2,
                    "copado__Type__c": "Function",
                    "Id": "a0t7Q000000N7q0QAC",
                    "Name": "Deploy"
                },
                {
                    "attributes": {
                        "type": "copado__JobStep__c",
                        "url": "/services/data/v55.0/sobjects/copado__JobStep__c/a0t7Q000000N7q1QAC"
                    },
                    "copado__ApiName__c": "sfdx_deploy_Encode Deploy changes",
                    "copado__ConfigJson__c": "{\"functionName\":\"sfdx_encode_file_names\",\"parameters\":[{\"name\":\"file_changes_id\",\"value\":\"{$Context.JobExecution__r.DataJson.fileWithSelectedChanges}\"},{\"name\":\"file_name\",\"value\":\"Copado Deploy changes\"}]}",
                    "copado__CustomType__c": "Function",
                    "copado__JobTemplate__c": "a0u7Q000000Xw29QAC",
                    "copado__Order__c": 1,
                    "copado__Type__c": "Function",
                    "Id": "a0t7Q000000N7q1QAC",
                    "Name": "Encode file names"
                },
                {
                    "attributes": {
                        "type": "copado__JobStep__c",
                        "url": "/services/data/v56.0/sobjects/copado__JobStep__c/a0t7Q000000N7q2QAC"
                    },
                    "copado__ApiName__c": "sfdx_promote_sfdx_promote",
                    "copado__ConfigJson__c": "{\"functionName\":\"sfdx_promote\",\"parameters\":[{\"name\":\"user_stories\",\"value\":\"{$Context.JobExecution__r.DataJson.userStoryBranches}\",\"required\":true},{\"name\":\"promotion_branch\",\"value\":\"{$Context.JobExecution__r.DataJson.promotionBranchName}\",\"required\":true},{\"name\":\"target_branch\",\"value\":\"{$Context.JobExecution__r.DataJson.destinationBranchName}\",\"required\":true},{\"name\":\"tag\",\"value\":\"{$Context.JobExecution__r.Promotion__r.Release__r.Version__c}\",\"required\":false},{\"name\":\"git_json\",\"value\":\"{$Context.Repository.Credential}\",\"required\":true},{\"name\":\"recreatePromotionBranch\",\"value\":\"{$Context.JobExecution__r.Promotion__r.cmcSf__Recreate_Promotion_Branch__c}\",\"required\":false},{\"name\":\"promotion_id\",\"value\":\"{$Job.ExecutionParent.Id}\"},{\"name\":\"file_changes_id\",\"value\":\"{$Context.JobExecution__r.DataJson.fileWithSelectedChanges}\"},{\"name\":\"conflict_resolution_attachments\",\"value\":\"{$Context.apex.GetConflictResolutionAttachments}\"},{\"name\":\"git_name\",\"value\":\"{$User.Name}\"},{\"name\":\"git_email\",\"value\":\"{$User.Email}\"},{\"name\":\"repository_id\",\"value\":\"{$Pipeline.Git_Repository__r.Id}\"},{\"name\":\"git_depth\",\"value\":\"100\",\"required\":true},{\"name\":\"maxBuffer\",\"value\":\"5242880\"},{\"name\":\"file_name\",\"value\":\"Copado Promotion changes\"},{\"name\":\"overriddenApiVersion\",\"value\":\"\"}]}",
                    "copado__CustomType__c": "Function",
                    "copado__JobTemplate__c": "a0u7Q000000Xw2AQAS",
                    "copado__Order__c": 1,
                    "copado__Type__c": "Function",
                    "Id": "a0t7Q000000N7q2QAC",
                    "Name": "Promote"
                },
                {
                    "attributes": {
                        "type": "copado__JobStep__c",
                        "url": "/services/data/v52.0/sobjects/copado__JobStep__c/a0s09000000KT2TAAW"
                    },
                    "copado__ApiName__c": "SFDX Package Import_Retrieve Package Information",
                    "copado__ConfigJson__c": "{\"functionName\":\"Devhub_Package_Info\",\"parameters\":[{\"name\":\"packageNameOrId\",\"value\":\"{$Context.JobExecution__r.DataJson.packageNameOrId}\"},{\"name\":\"session\",\"value\":\"{$Source.Credential.SessionId}\"},{\"name\":\"baseUrl\",\"value\":\"{$Source.Credential.Endpoint}\"}]}",
                    "copado__JobTemplate__c": "a0t09000002vfccAAA",
                    "copado__Order__c": 2,
                    "copado__CustomType__c": "Function",
                    "copado__Type__c": "Function",
                    "CreatedDate": "2021-10-04T09:11:43.000+0000",
                    "Id": "a0s09000000KT2TAAW",
                    "IsDeleted": false,
                    "LastModifiedDate": "2021-10-04T09:59:20.000+0000",
                    "Name": "Retrieve Package Information",
                    "SystemModstamp": "2021-10-04T09:59:20.000+0000"
                },
                {
                    "attributes": {
                        "type": "copado__JobStep__c",
                        "url": "/services/data/v53.0/sobjects/copado__JobStep__c/a0s09000000KT2UAAW"
                    },
                    "copado__ApiName__c": "SFDX Package Import_Upsert Package Information",
                    "copado__ConfigJson__c": "{\"flowName\":\"cmcSf.ImportPackageAndVersions\",\"parameters\":[{\"name\":\"packageJson\",\"value\":\"{$Job.PrevStep.Result__r.Result_Data__c}\"},{\"name\":\"pipelineId\",\"value\":\"{$Context.JobExecution__r.DataJson.pipelineId}\"},{\"name\":\"jsonInformation\",\"value\":\"{$Context.JobExecution__r.DataJson.jsonInformation}\"},{\"name\":\"type\",\"value\":\"wait\"}]}",
                    "copado__JobTemplate__c": "a0t09000002vfccAAA",
                    "copado__Order__c": 3,
                    "copado__CustomType__c": "Flow",
                    "copado__Type__c": "Flow",
                    "CreatedDate": "2021-10-04T09:11:43.000+0000",
                    "Id": "a0s09000000KT2UAAW",
                    "IsDeleted": false,
                    "LastModifiedDate": "2021-10-31T21:44:48.000+0000",
                    "Name": "Upsert Package Information",
                    "SystemModstamp": "2021-10-31T21:44:48.000+0000"
                },
                {
                    "attributes": {
                        "type": "copado__JobStep__c",
                        "url": "/services/data/v52.0/sobjects/copado__JobStep__c/a0s09000000KT2WAAW"
                    },
                    "copado__ApiName__c": "SFDX Package Import_Update Source on Job Execution",
                    "copado__ConfigJson__c": "{\"flowName\":\"cmcSf.Update_Source_on_Job_Execution\",\"parameters\":[{\"name\":\"type\",\"value\":\"wait\"},{\"name\":\"jsonInformation\",\"value\":\"{$Context.JobExecution__r.DataJson.jsonInformation}\"}]}",
                    "copado__JobTemplate__c": "a0t09000002vfccAAA",
                    "copado__Order__c": 1,
                    "copado__CustomType__c": "Flow",
                    "copado__Type__c": "Flow",
                    "CreatedDate": "2021-10-04T09:14:13.000+0000",
                    "Id": "a0s09000000KT2WAAW",
                    "IsDeleted": false,
                    "LastModifiedDate": "2021-10-04T10:48:24.000+0000",
                    "Name": "Update Source on Job Execution",
                    "SystemModstamp": "2021-10-04T10:48:24.000+0000"
                },
                {
                    "attributes": {
                        "type": "copado__JobStep__c",
                        "url": "/services/data/v56.0/sobjects/copado__JobStep__c/a0t7Q00000720dNQAQ"
                    },
                    "copado__ApiName__c": "SFDX Package Version Publish_Promote Package to Release",
                    "copado__ConfigJson__c": "{\"functionName\":\"sfdx_package_version_publish\",\"parameters\":[{\"name\":\"versionDetails\",\"value\":\"{$Job.PrevStep.Result__r.Result_Data__c}\",\"required\":true},{\"name\":\"sessionId\",\"value\":\"{$Destination.Credential.SessionId}\",\"required\":true},{\"name\":\"endpoint\",\"value\":\"{$Destination.Credential.Endpoint}\",\"required\":true}]}",
                    "copado__CustomType__c": "Function",
                    "copado__JobTemplate__c": "a0u7Q0000004wGqQAI",
                    "copado__Order__c": 2,
                    "copado__Type__c": "Function",
                    "Id": "a0t7Q00000720dNQAQ",
                    "Name": "Publish Package Version"
                },
                {
                    "attributes": {
                        "type": "copado__JobStep__c",
                        "url": "/services/data/v56.0/sobjects/copado__JobStep__c/a0t7Q00000720dOQAQ"
                    },
                    "copado__ApiName__c": "SFDX Package Version Publish_Update Destination on Job Execution",
                    "copado__ConfigJson__c": "{\"flowName\":\"cmcSf.UpdatePackageVersionRequisite\",\"parameters\":[{\"name\":\"packageVersionId\",\"value\":\"{$Context.JobExecution__r.DataJson.packageVersionId}\"},{\"name\":\"type\",\"value\":\"wait\"}]}",
                    "copado__CustomType__c": "Flow",
                    "copado__JobTemplate__c": "a0u7Q0000004wGqQAI",
                    "copado__Order__c": 1,
                    "copado__Type__c": "Flow",
                    "Id": "a0t7Q00000720dOQAQ",
                    "Name": "Update Package Version Requisite"
                },
                {
                    "attributes": {
                        "type": "copado__JobStep__c",
                        "url": "/services/data/v56.0/sobjects/copado__JobStep__c/a0t7Q000001Re2XQAS"
                    },
                    "copado__ApiName__c": "SFDX Package Version Update_Update Package Version",
                    "copado__ConfigJson__c": "{\"functionName\":\"SFDX_Package_Version_Update\",\"parameters\":[{\"name\":\"devhubSession\",\"value\":\"{$Destination.Credential.SessionId}\",\"required\":true},{\"name\":\"devhubEndpoint\",\"value\":\"{$Destination.Credential.Endpoint}\",\"required\":true},{\"name\":\"packageVersion\",\"value\":\"{$Context.JobExecution__r.DataJson.packageVersion}\",\"required\":false},{\"name\":\"installationKey\",\"value\":\"{$Context.JobExecution__r.DataJson.installationKey}\"},{\"name\":\"apiVersion\",\"value\":\"{$Context.JobExecution__r.DataJson.apiVersion}\"}]}",
                    "copado__CustomType__c": "Function",
                    "copado__JobTemplate__c": "a0u7Q0000004wGrQAI",
                    "copado__Order__c": 1,
                    "copado__Type__c": "Function",
                    "Id": "a0t7Q000001Re2XQAS",
                    "Name": "Update Package Version"
                },
                {
                    "attributes": {
                        "type": "copado__JobStep__c",
                        "url": "/services/data/v56.0/sobjects/copado__JobStep__c/a0t7Q000001Re2YQAS"
                    },
                    "copado__ApiName__c": "SFDX Package Version Update_Update Records",
                    "copado__ConfigJson__c": "{\"flowName\":\"cmcSf.UpdatePackageVersion\",\"parameters\":[{\"name\":\"newVersion\",\"value\":\"{$Job.PrevStep.Result__r.Result_Data__c}\"},{\"name\":\"type\",\"value\":\"wait\"}]}",
                    "copado__CustomType__c": "Flow",
                    "copado__JobTemplate__c": "a0u7Q0000004wGrQAI",
                    "copado__Order__c": 2,
                    "copado__Type__c": "Flow",
                    "Id": "a0t7Q000001Re2YQAS",
                    "Name": "Update Records"
                },
                {
                    "attributes": {
                        "type": "copado__JobStep__c",
                        "url": "/services/data/v56.0/sobjects/copado__JobStep__c/a0t7Q000001Re2ZQAS"
                    },
                    "copado__ApiName__c": "SFDX Package Version Create_Create SFDX Package Version",
                    "copado__ConfigJson__c": "{\"functionName\":\"SFDX_Package_Version_Create\",\"parameters\":[{\"name\":\"endPoint\",\"value\":\"{$Destination.Credential.Endpoint}\",\"required\":true},{\"name\":\"session\",\"value\":\"{$Destination.Credential.SessionId}\",\"required\":true},{\"name\":\"packageId\",\"value\":\"{$Job.PrevStep.Result__r.Result_Data__c}\",\"required\":false},{\"name\":\"versionName\",\"value\":\"{$Context.JobExecution__r.DataJson.versionName}\"},{\"name\":\"versionNumber\",\"value\":\"{$Context.JobExecution__r.DataJson.versionNumber}\"},{\"name\":\"description\",\"value\":\"{$Context.JobExecution__r.DataJson.description}\"},{\"name\":\"jsonInformation\",\"value\":\"{$Context.JobExecution__r.DataJson.jsonInformation}\",\"required\":false},{\"name\":\"git_json\",\"value\":\"{$Context.Repository.Credential}\",\"required\":true},{\"name\":\"gitName\",\"value\":\"{$User.Name}\"},{\"name\":\"gitEmail\",\"value\":\"{$User.Email}\"}]}",
                    "copado__CustomType__c": "Function",
                    "copado__JobTemplate__c": "a0u7Q0000004wGsQAI",
                    "copado__Order__c": 2,
                    "copado__Type__c": "Function",
                    "Id": "a0t7Q000001Re2ZQAS",
                    "Name": "Create SFDX Package Version"
                },
                {
                    "attributes": {
                        "type": "copado__JobStep__c",
                        "url": "/services/data/v56.0/sobjects/copado__JobStep__c/a0t7Q000001Re2aQAC"
                    },
                    "copado__ApiName__c": "SFDX Package Version Create_Update Destination on Job Execution",
                    "copado__ConfigJson__c": "{\"flowName\":\"cmcSf.UpdatePackageRequisite\",\"parameters\":[{\"name\":\"packageId\",\"value\":\"{$Context.JobExecution__r.DataJson.packageId}\"},{\"name\":\"type\",\"value\":\"wait\"}]}",
                    "copado__CustomType__c": "Flow",
                    "copado__JobTemplate__c": "a0u7Q0000004wGsQAI",
                    "copado__Order__c": 1,
                    "copado__Type__c": "Flow",
                    "Id": "a0t7Q000001Re2aQAC",
                    "Name": "Update Package Requisite"
                },
                {
                    "attributes": {
                        "type": "copado__JobStep__c",
                        "url": "/services/data/v56.0/sobjects/copado__JobStep__c/a0t7Q000001Re2bQAC"
                    },
                    "copado__ApiName__c": "SFDX Package Version Publish_Insert Package Version Information",
                    "copado__ConfigJson__c": "{\"flowName\":\"cmcSf.CreatePackageVersion\",\"parameters\":[{\"name\":\"packageVersionJson\",\"value\":\"{$Job.PrevStep.Result__r.Result_Data__c}\"},{\"name\":\"jsonInformation\",\"value\":\"{$Context.JobExecution__r.DataJson.jsonInformation}\"}]}",
                    "copado__CustomType__c": "Flow",
                    "copado__JobTemplate__c": "a0u7Q0000004wGsQAI",
                    "copado__Order__c": 3,
                    "copado__Type__c": "Flow",
                    "Id": "a0t7Q000001Re2bQAC",
                    "Name": "Insert Package Version Information"
                },
                {
                    "attributes": {
                        "type": "copado__JobStep__c",
                        "url": "/services/data/v56.0/sobjects/copado__JobStep__c/a0t7Q000002nFwNQAU"
                    },
                    "copado__ApiName__c": "SFDX Package Create_Create Package on Destination",
                    "copado__ConfigJson__c": "{\"functionName\":\"SFDXPackageCreate\",\"parameters\":[{\"name\":\"devhubEndpoint\",\"value\":\"{$Destination.Credential.Endpoint}\",\"required\":true},{\"name\":\"devhubSession\",\"value\":\"{$Destination.Credential.SessionId}\",\"required\":true},{\"name\":\"packageName\",\"value\":\"{$Job.ExecutionParent.Name}\",\"required\":false},{\"name\":\"path\",\"value\":\"{$Job.ExecutionParent.cmcSf__PackagePath__c}\"},{\"name\":\"jsonInformation\",\"value\":\"{$Context.JobExecution__r.DataJson.jsonInformation}\"},{\"name\":\"description\",\"value\":\"{$Job.ExecutionParent.copado__Description__c}\"},{\"name\":\"git_json\",\"value\":\"{$Context.Repository.Credential}\",\"required\":true},{\"name\":\"branch\",\"value\":\"{$Job.ExecutionParent.copado__DefaultBranch__c}\"},{\"name\":\"gitName\",\"value\":\"{$User.Name}\"},{\"name\":\"gitEmail\",\"value\":\"{$User.Email}\"}]}",
                    "copado__CustomType__c": "Function",
                    "copado__JobTemplate__c": "a0u7Q0000004wGtQAI",
                    "copado__Order__c": 2,
                    "copado__Type__c": "Function",
                    "Id": "a0t7Q000002nFwNQAU",
                    "Name": "Create Package on Destination"
                },
                {
                    "attributes": {
                        "type": "copado__JobStep__c",
                        "url": "/services/data/v56.0/sobjects/copado__JobStep__c/a0t7Q000002nFwOQAU"
                    },
                    "copado__ApiName__c": "SFDX Package Create_Update Package",
                    "copado__ConfigJson__c": "{\"flowName\":\"cmcSf.UpdatePackage\",\"parameters\":[{\"name\":\"packageRecordId\",\"value\":\"{$Context.JobExecution__r.DataJson.packageId}\"},{\"name\":\"packageInfo\",\"value\":\"{$Job.PrevStep.Result__r.Result_Data__c}\"}]}",
                    "copado__CustomType__c": "Salesforce Flow",
                    "copado__JobTemplate__c": "a0u7Q0000004wGtQAI",
                    "copado__Order__c": 3,
                    "copado__Type__c": "Flow",
                    "Id": "a0t7Q000002nFwOQAU",
                    "Name": "Update Package"
                },
                {
                    "attributes": {
                        "type": "copado__JobStep__c",
                        "url": "/services/data/v56.0/sobjects/copado__JobStep__c/a0t7Q000002nFwPQAU"
                    },
                    "copado__ApiName__c": "SFDX Package Create_Update Destination on Job Ex",
                    "copado__ConfigJson__c": "{\"flowName\":\"cmcSf.UpdateDestinationOnJobExecution\",\"parameters\":[{\"name\":\"packageId\",\"value\":\"{$Context.JobExecution__r.DataJson.packageId}\"}]}",
                    "copado__CustomType__c": "Flow",
                    "copado__JobTemplate__c": "a0u7Q0000004wGtQAI",
                    "copado__Order__c": 1,
                    "copado__Type__c": "Flow",
                    "Id": "a0t7Q000002nFwPQAU",
                    "Name": "Update Destination on Job Execution"
                },
                {
                    "attributes": {
                        "type": "copado__JobStep__c",
                        "url": "/services/data/v54.0/sobjects/copado__JobStep__c/a0t7Q000000Li7RQAS"
                    },
                    "copado__ApiName__c": "SFDX Run Apex Tests_Run Apex Tests",
                    "copado__ConfigJson__c": "{\"functionName\":\"SFDXRunApexTests\",\"parameters\":[{\"name\":\"source_session_id\",\"value\":\"{$Source.Credential.SessionId}\"},{\"name\":\"source_endpoint\",\"value\":\"{$Source.Credential.Endpoint}\"},{\"name\":\"namespace\",\"value\":\"\"},{\"name\":\"source_path\",\"value\":\"force-app\"},{\"name\":\"test_minutes_timeout\",\"value\":\"1440\"},{\"name\":\"test_result_ids\",\"value\":\"{$Context.JobExecution__r.DataJson.resultIds}\"},{\"name\":\"test_classes\",\"value\":\"{$Context.apex.cmcSf.GetTestClasses}\"},{\"name\":\"consolidated_result_id\",\"value\":\"{$Context.JobExecution__r.DataJson.resultId}\"}]}",
                    "copado__CustomType__c": "Function",
                    "copado__JobTemplate__c": "a0u7Q000000XrrkQAC",
                    "copado__Order__c": 3,
                    "copado__Type__c": "Function",
                    "Id": "a0t7Q000000Li7RQAS",
                    "Name": "Run Apex Tests"
                },
                {
                    "attributes": {
                        "type": "copado__JobStep__c",
                        "url": "/services/data/v54.0/sobjects/copado__JobStep__c/a0t7Q000000Li7SQAS"
                    },
                    "copado__ApiName__c": "SFDX Run Apex Tests_Populate Source Environment",
                    "copado__ConfigJson__c": "{\"flowName\":\"cmcSf.SetSourceEnvironmentOnApexTestJobExecution\",\"parameters\":[{\"name\":\"jobExecutionId\",\"value\":\"{$Context.JobExecution__r.Id}\"},{\"name\":\"testIds\",\"value\":\"{$Context.JobExecution__r.DataJson.testIds}\"}]}",
                    "copado__CustomType__c": "Salesforce Flow",
                    "copado__JobTemplate__c": "a0u7Q000000XrrkQAC",
                    "copado__Order__c": 1,
                    "copado__Type__c": "Flow",
                    "Id": "a0t7Q000000Li7SQAS",
                    "Name": "Set Source Environment"
                },
                {
                    "attributes": {
                        "type": "copado__JobStep__c",
                        "url": "/services/data/v54.0/sobjects/copado__JobStep__c/a0t7Q000000Li7TQAS"
                    },
                    "copado__ApiName__c": "SFDX Run Apex Tests_Evaluate Apex Tests Acceptance Criteria",
                    "copado__ConfigJson__c": "{\"flowName\":\"cmcSf.EvaluateApexTestsAcceptanceCriteria\",\"parameters\":[{\"name\":\"acceptanceCriteria\",\"value\":\"{$Context.JobExecution__r.DataJson.acceptanceCriteria}\"},{\"name\":\"resultIds\",\"value\":\"{$Context.JobExecution__r.DataJson.resultIds}\"},{\"name\":\"consolidatedResultId\",\"value\":\"{$Context.JobExecution__r.DataJson.resultId}\"}]}",
                    "copado__CustomType__c": "Salesforce Flow",
                    "copado__JobTemplate__c": "a0u7Q000000XrrkQAC",
                    "copado__Order__c": 4,
                    "copado__Type__c": "Flow",
                    "Id": "a0t7Q000000Li7TQAS",
                    "Name": "Evaluate Apex Tests Acceptance Criteria"
                },
                {
                    "attributes": {
                        "type": "copado__JobStep__c",
                        "url": "/services/data/v56.0/sobjects/copado__JobStep__c/a0t7Q000007JaxEQAS"
                    },
                    "copado__ApiName__c": "SFDX Package Version Git Configure_Git Config",
                    "copado__ConfigJson__c": "{\"functionName\":\"SFDX_Package_Version_Git_Config\",\"parameters\":[{\"name\":\"packageVersion\",\"value\":\"{$Context.JobExecution__r.DataJson.packageVersion}\",\"required\":true},{\"name\":\"git_json\",\"value\":\"{$Context.Repository.Credential}\",\"required\":true},{\"name\":\"dxNamespace\",\"value\":\"{$Context.apex.cmcSf.GetDxNamespace}\"}]}",
                    "copado__CustomType__c": "Function",
                    "copado__JobTemplate__c": "a0u7Q0000004yiqQAA",
                    "copado__Order__c": 1,
                    "copado__Type__c": "Function",
                    "Id": "a0t7Q000007JaxEQAS",
                    "Name": "Git Config"
                },
                {
                    "attributes": {
                        "type": "copado__JobStep__c",
                        "url": "/services/data/v56.0/sobjects/copado__JobStep__c/a0t7Q000007JaxFQAS"
                    },
                    "copado__ApiName__c": "SFDX Package Version Git Configure_1_Update Record",
                    "copado__ConfigJson__c": "{\"flowName\":\"cmcSf.UpdatePackageVersion\",\"parameters\":[{\"name\":\"newVersion\",\"value\":\"{$Job.PrevStep.Result__r.Result_Data__c}\"},{\"name\":\"type\",\"value\":\"wait\"}]}",
                    "copado__CustomType__c": "Salesforce Flow",
                    "copado__JobTemplate__c": "a0u7Q0000004yiqQAA",
                    "copado__Order__c": 2,
                    "copado__Type__c": "Flow",
                    "Id": "a0t7Q000007JaxFQAS",
                    "Name": "Update Record"
                },
                {
                    "attributes": {
                        "type": "copado__JobStep__c",
                        "url": "/services/data/v55.0/sobjects/copado__JobStep__c/a0s090000020VnJAAU"
                    },
                    "copado__ApiName__c": "SFDX Test Records Creation In User Story_1_Apex Test Record Automation_1",
                    "copado__ConfigJson__c": "{\"flowName\":\"cmcSf.Apex_Test_Record_Automation\",\"parameters\":[{\"name\":\"userStoryId\",\"value\":\"{$Context.JobExecution__r.DataJson.userStoryId}\"},{\"name\":\"recreateFeatureBranch\",\"value\":\"{$Context.JobExecution__r.DataJson.recreateFeatureBranch}\"}]}",
                    "copado__CustomType__c": "Salesforce Flow",
                    "copado__JobTemplate__c": "a0t09000000lkYtAAI",
                    "copado__Order__c": 1,
                    "copado__Type__c": "Flow",
                    "Id": "a0s090000020VnJAAU",
                    "Name": "Apex Test Record Automation"
                },
                {
                    "attributes": {
                        "type": "copado__JobStep__c",
                        "url": "/services/data/v56.0/sobjects/copado__JobStep__c/a0s090000020XIKAA2"
                    },
                    "copado__ApiName__c": "SFDX Metadata Refresh_1_Metadata Refresh_1",
                    "copado__ConfigJson__c": "{\"functionName\":\"SFDX_Refresh_Metadata\",\"parameters\":[{\"name\":\"SESSION_ID\",\"value\":\"{$Source.Credential.SessionId}\",\"required\":true},{\"name\":\"ENDPOINT\",\"value\":\"{$Source.Credential.Endpoint}\",\"required\":true},{\"name\":\"METADATA_FILE_ID\",\"value\":\"{$Context.JobExecution__r.DataJson.metadataFileId}\",\"required\":false},{\"name\":\"IGNORED_TYPE\",\"value\":\"{$Context.JobExecution__r.DataJson.ignoredType}\"},{\"name\":\"TYPE_FILTER\",\"value\":\"{$Context.JobExecution__r.DataJson.typeFilter}\"},{\"name\":\"MAX_BUFFER\",\"value\":\"5242880\"}]}",
                    "copado__CustomType__c": "Function",
                    "copado__JobTemplate__c": "a0t09000000llqoAAA",
                    "copado__Order__c": 1,
                    "copado__Type__c": "Function",
                    "Id": "a0s090000020XIKAA2",
                    "Name": "Refresh Metadata"
                }
            ],
            "ObjectType": "copado__JobStep__c"
        }
    ],
    "blobsByUID": {}
}
